// created by jay 1.0.2 (c) 2002-2004 ats@cs.rit.edu
// skeleton Java 1.0 (c) 2002 ats@cs.rit.edu

					// line 2 "RubyParser.y"
/*
 **** BEGIN LICENSE BLOCK *****
 * Version: EPL 2.0/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Eclipse Public
 * License Version 2.0 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy of
 * the License at http://www.eclipse.org/legal/epl-v20.html
 *
 * Software distributed under the License is distributed on an "AS
 * IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * Copyright (C) 2008-2017 Thomas E Enebo <enebo@acm.org>
 * 
 * Alternatively, the contents of this file may be used under the terms of
 * either of the GNU General Public License Version 2 or later (the "GPL"),
 * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the EPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the EPL, the GPL or the LGPL.
 ***** END LICENSE BLOCK *****/

package org.jruby.parser;

import java.io.IOException;

import org.jruby.RubySymbol;
import org.jruby.ast.ArgsNode;
import org.jruby.ast.ArgumentNode;
import org.jruby.ast.ArrayNode;
import org.jruby.ast.AssignableNode;
import org.jruby.ast.BackRefNode;
import org.jruby.ast.BeginNode;
import org.jruby.ast.BlockAcceptingNode;
import org.jruby.ast.BlockArgNode;
import org.jruby.ast.BlockNode;
import org.jruby.ast.BlockPassNode;
import org.jruby.ast.BreakNode;
import org.jruby.ast.ClassNode;
import org.jruby.ast.ClassVarNode;
import org.jruby.ast.ClassVarAsgnNode;
import org.jruby.ast.Colon3Node;
import org.jruby.ast.ConstNode;
import org.jruby.ast.ConstDeclNode;
import org.jruby.ast.DefinedNode;
import org.jruby.ast.DStrNode;
import org.jruby.ast.DSymbolNode;
import org.jruby.ast.DXStrNode;
import org.jruby.ast.DefnNode;
import org.jruby.ast.DefsNode;
import org.jruby.ast.DotNode;
import org.jruby.ast.EncodingNode;
import org.jruby.ast.EnsureNode;
import org.jruby.ast.EvStrNode;
import org.jruby.ast.FalseNode;
import org.jruby.ast.FileNode;
import org.jruby.ast.FCallNode;
import org.jruby.ast.FixnumNode;
import org.jruby.ast.FloatNode;
import org.jruby.ast.ForNode;
import org.jruby.ast.GlobalAsgnNode;
import org.jruby.ast.GlobalVarNode;
import org.jruby.ast.HashNode;
import org.jruby.ast.InstAsgnNode;
import org.jruby.ast.InstVarNode;
import org.jruby.ast.IterNode;
import org.jruby.ast.KeywordArgNode;
import org.jruby.ast.LambdaNode;
import org.jruby.ast.ListNode;
import org.jruby.ast.LiteralNode;
import org.jruby.ast.ModuleNode;
import org.jruby.ast.MultipleAsgnNode;
import org.jruby.ast.NextNode;
import org.jruby.ast.NilImplicitNode;
import org.jruby.ast.NilNode;
import org.jruby.ast.Node;
import org.jruby.ast.NonLocalControlFlowNode;
import org.jruby.ast.NumericNode;
import org.jruby.ast.OptArgNode;
import org.jruby.ast.PostExeNode;
import org.jruby.ast.PreExe19Node;
import org.jruby.ast.RationalNode;
import org.jruby.ast.RedoNode;
import org.jruby.ast.RegexpNode;
import org.jruby.ast.RequiredKeywordArgumentValueNode;
import org.jruby.ast.RescueBodyNode;
import org.jruby.ast.RestArgNode;
import org.jruby.ast.RetryNode;
import org.jruby.ast.ReturnNode;
import org.jruby.ast.SClassNode;
import org.jruby.ast.SelfNode;
import org.jruby.ast.StarNode;
import org.jruby.ast.StrNode;
import org.jruby.ast.TrueNode;
import org.jruby.ast.UnnamedRestArgNode;
import org.jruby.ast.UntilNode;
import org.jruby.ast.VAliasNode;
import org.jruby.ast.WhileNode;
import org.jruby.ast.XStrNode;
import org.jruby.ast.YieldNode;
import org.jruby.ast.ZArrayNode;
import org.jruby.ast.ZSuperNode;
import org.jruby.ast.types.ILiteralNode;
import org.jruby.common.IRubyWarnings;
import org.jruby.common.IRubyWarnings.ID;
import org.jruby.lexer.LexerSource;
import org.jruby.lexer.LexingCommon;
import org.jruby.lexer.yacc.RubyLexer;
import org.jruby.lexer.yacc.StrTerm;
import org.jruby.lexer.yacc.SyntaxException.PID;
import org.jruby.util.ByteList;
import org.jruby.util.CommonByteLists;
import org.jruby.util.KeyValuePair;
import org.jruby.util.StringSupport;
import static org.jruby.lexer.LexingCommon.EXPR_BEG;
import static org.jruby.lexer.LexingCommon.EXPR_FITEM;
import static org.jruby.lexer.LexingCommon.EXPR_FNAME;
import static org.jruby.lexer.LexingCommon.EXPR_ENDFN;
import static org.jruby.lexer.LexingCommon.EXPR_ENDARG;
import static org.jruby.lexer.LexingCommon.EXPR_END;
import static org.jruby.lexer.LexingCommon.EXPR_LABEL;
import static org.jruby.parser.ParserSupport.arg_blk_pass;
import static org.jruby.parser.ParserSupport.node_assign;
import static org.jruby.parser.ParserSupport.value_expr;

 
public class RubyParser {
    protected ParserSupport support;
    protected RubyLexer lexer;

    public RubyParser(LexerSource source, IRubyWarnings warnings) {
        this.support = new ParserSupport();
        this.lexer = new RubyLexer(support, source, warnings);
        support.setLexer(lexer);
        support.setWarnings(warnings);
    }

    @Deprecated
    public RubyParser(LexerSource source) {
        this(new ParserSupport(), source);
    }

    @Deprecated
    public RubyParser(ParserSupport support, LexerSource source) {
        this.support = support;
        lexer = new RubyLexer(support, source);
        support.setLexer(lexer);
    }

    public void setWarnings(IRubyWarnings warnings) {
        support.setWarnings(warnings);
        lexer.setWarnings(warnings);
    }
					// line 166 "-"
  // %token constants
  public static final int keyword_class = 257;
  public static final int keyword_module = 258;
  public static final int keyword_def = 259;
  public static final int keyword_undef = 260;
  public static final int keyword_begin = 261;
  public static final int keyword_rescue = 262;
  public static final int keyword_ensure = 263;
  public static final int keyword_end = 264;
  public static final int keyword_if = 265;
  public static final int keyword_unless = 266;
  public static final int keyword_then = 267;
  public static final int keyword_elsif = 268;
  public static final int keyword_else = 269;
  public static final int keyword_case = 270;
  public static final int keyword_when = 271;
  public static final int keyword_while = 272;
  public static final int keyword_until = 273;
  public static final int keyword_for = 274;
  public static final int keyword_break = 275;
  public static final int keyword_next = 276;
  public static final int keyword_redo = 277;
  public static final int keyword_retry = 278;
  public static final int keyword_in = 279;
  public static final int keyword_do = 280;
  public static final int keyword_do_cond = 281;
  public static final int keyword_do_block = 282;
  public static final int keyword_return = 283;
  public static final int keyword_yield = 284;
  public static final int keyword_super = 285;
  public static final int keyword_self = 286;
  public static final int keyword_nil = 287;
  public static final int keyword_true = 288;
  public static final int keyword_false = 289;
  public static final int keyword_and = 290;
  public static final int keyword_or = 291;
  public static final int keyword_not = 292;
  public static final int modifier_if = 293;
  public static final int modifier_unless = 294;
  public static final int modifier_while = 295;
  public static final int modifier_until = 296;
  public static final int modifier_rescue = 297;
  public static final int keyword_alias = 298;
  public static final int keyword_defined = 299;
  public static final int keyword_BEGIN = 300;
  public static final int keyword_END = 301;
  public static final int keyword__LINE__ = 302;
  public static final int keyword__FILE__ = 303;
  public static final int keyword__ENCODING__ = 304;
  public static final int keyword_do_lambda = 305;
  public static final int tIDENTIFIER = 306;
  public static final int tFID = 307;
  public static final int tGVAR = 308;
  public static final int tIVAR = 309;
  public static final int tCONSTANT = 310;
  public static final int tCVAR = 311;
  public static final int tLABEL = 312;
  public static final int tCHAR = 313;
  public static final int tUPLUS = 314;
  public static final int tUMINUS = 315;
  public static final int tUMINUS_NUM = 316;
  public static final int tPOW = 317;
  public static final int tCMP = 318;
  public static final int tEQ = 319;
  public static final int tEQQ = 320;
  public static final int tNEQ = 321;
  public static final int tGEQ = 322;
  public static final int tLEQ = 323;
  public static final int tANDOP = 324;
  public static final int tOROP = 325;
  public static final int tMATCH = 326;
  public static final int tNMATCH = 327;
  public static final int tDOT = 328;
  public static final int tDOT2 = 329;
  public static final int tDOT3 = 330;
  public static final int tAREF = 331;
  public static final int tASET = 332;
  public static final int tLSHFT = 333;
  public static final int tRSHFT = 334;
  public static final int tANDDOT = 335;
  public static final int tCOLON2 = 336;
  public static final int tCOLON3 = 337;
  public static final int tOP_ASGN = 338;
  public static final int tASSOC = 339;
  public static final int tLPAREN = 340;
  public static final int tLPAREN2 = 341;
  public static final int tRPAREN = 342;
  public static final int tLPAREN_ARG = 343;
  public static final int tLBRACK = 344;
  public static final int tRBRACK = 345;
  public static final int tLBRACE = 346;
  public static final int tLBRACE_ARG = 347;
  public static final int tSTAR = 348;
  public static final int tSTAR2 = 349;
  public static final int tAMPER = 350;
  public static final int tAMPER2 = 351;
  public static final int tTILDE = 352;
  public static final int tPERCENT = 353;
  public static final int tDIVIDE = 354;
  public static final int tPLUS = 355;
  public static final int tMINUS = 356;
  public static final int tLT = 357;
  public static final int tGT = 358;
  public static final int tPIPE = 359;
  public static final int tBANG = 360;
  public static final int tCARET = 361;
  public static final int tLCURLY = 362;
  public static final int tRCURLY = 363;
  public static final int tBACK_REF2 = 364;
  public static final int tSYMBEG = 365;
  public static final int tSTRING_BEG = 366;
  public static final int tXSTRING_BEG = 367;
  public static final int tREGEXP_BEG = 368;
  public static final int tWORDS_BEG = 369;
  public static final int tQWORDS_BEG = 370;
  public static final int tSTRING_DBEG = 371;
  public static final int tSTRING_DVAR = 372;
  public static final int tSTRING_END = 373;
  public static final int tLAMBDA = 374;
  public static final int tLAMBEG = 375;
  public static final int tNTH_REF = 376;
  public static final int tBACK_REF = 377;
  public static final int tSTRING_CONTENT = 378;
  public static final int tINTEGER = 379;
  public static final int tIMAGINARY = 380;
  public static final int tFLOAT = 381;
  public static final int tRATIONAL = 382;
  public static final int tREGEXP_END = 383;
  public static final int tSYMBOLS_BEG = 384;
  public static final int tQSYMBOLS_BEG = 385;
  public static final int tDSTAR = 386;
  public static final int tSTRING_DEND = 387;
  public static final int tLABEL_END = 388;
  public static final int tLOWEST = 389;
  public static final int yyErrorCode = 256;

  /** number of final state.
    */
  protected static final int yyFinal = 1;

  /** parser tables.
      Order is mandated by <i>jay</i>.
    */
  protected static final short[] yyLhs = {
//yyLhs 655
    -1,   153,     0,   139,   140,   140,   140,   140,   141,   141,
   156,    37,    37,    36,    38,    38,    38,    38,    44,   157,
    44,   158,    39,    39,    39,    39,    39,    39,    39,    39,
    39,    39,    39,    39,    39,    39,    39,    39,    31,    31,
    31,    31,    31,    31,    31,    31,    61,    61,    61,    40,
    40,    40,    40,    40,    40,    45,    32,    32,    60,    60,
   113,   148,    43,    43,    43,    43,    43,    43,    43,    43,
    43,    43,    43,   116,   116,   127,   127,   117,   117,   117,
   117,   117,   117,   117,   117,   117,   117,    74,    74,   103,
   103,   104,   104,    75,    75,    75,    75,    75,    75,    75,
    75,    75,    75,    75,    75,    75,    75,    75,    75,    75,
    75,    75,    80,    80,    80,    80,    80,    80,    80,    80,
    80,    80,    80,    80,    80,    80,    80,    80,    80,    80,
    80,     8,     8,    30,    30,    30,     7,     7,     7,     7,
     7,   120,   120,   121,   121,    64,   160,    64,     6,     6,
     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,
     6,     6,     6,     6,     6,     6,     6,     6,     6,     6,
     6,     6,     6,     6,     6,     6,     6,     6,   134,   134,
   134,   134,   134,   134,   134,   134,   134,   134,   134,   134,
   134,   134,   134,   134,   134,   134,   134,   134,   134,   134,
   134,   134,   134,   134,   134,   134,   134,   134,   134,   134,
   134,   134,   134,   134,   134,   134,   134,   134,   134,   134,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,    41,    41,    41,    41,    41,    41,    41,    41,    41,
    41,   136,   136,   136,   136,    51,    51,    76,    79,    79,
    79,    79,    62,    62,    54,    58,    58,   130,   130,   130,
   130,   130,    52,    52,    52,    52,    52,   162,    56,   107,
   106,   106,    82,    82,    82,    82,    35,    35,    73,    73,
    73,    42,    42,    42,    42,    42,    42,    42,    42,    42,
    42,    42,   163,    42,   164,    42,   165,   166,    42,    42,
    42,    42,    42,    42,    42,    42,    42,    42,    42,    42,
    42,    42,    42,    42,    42,    42,    42,   168,   170,    42,
   171,   172,    42,    42,    42,   173,   174,    42,   175,    42,
   177,    42,   178,    42,   179,   180,    42,   181,   182,    42,
    42,    42,    42,    42,    46,   150,   152,   151,   149,   167,
   167,   167,   169,   169,    49,    49,    47,    47,   129,   129,
   131,   131,    87,    87,   132,   132,   132,   132,   132,   132,
   132,   132,   132,    94,    94,    94,    94,    93,    93,    69,
    69,    69,    69,    69,    69,    69,    69,    69,    69,    69,
    69,    69,    69,    69,    71,    71,    70,    70,    70,   124,
   124,   123,   123,   133,   133,   183,   184,   126,    68,    68,
   125,   125,   112,    59,    59,    59,    59,    22,    22,    22,
    22,    22,    22,    22,    22,    22,   111,   111,   185,   186,
   114,   187,   188,   115,    77,    48,    48,   118,   118,    78,
    78,    78,    50,    50,    53,    53,    28,    28,    28,    15,
    16,    16,    16,    17,    18,    19,    25,    84,    84,    27,
    27,    90,    88,    88,    26,    91,    83,    83,    89,    89,
    20,    20,    21,    21,    24,    24,    23,   189,    23,   190,
   191,   192,   193,   194,    23,    65,    65,    65,    65,     2,
     1,     1,     1,     1,    29,    33,    33,    34,    34,    34,
    34,    57,    57,    57,    57,    57,    57,    57,    57,    57,
    57,    57,    57,   119,   119,   119,   119,   119,   119,   119,
   119,   119,   119,   119,   119,    66,    66,   195,    55,    55,
    72,   196,    72,    95,    95,    95,    95,    92,    92,    67,
    67,    67,    67,    67,    67,    67,    67,    67,    67,    67,
    67,    67,    67,    67,   135,   135,   135,   135,     9,     9,
   147,   122,   122,    85,    85,   144,    96,    96,    97,    97,
    98,    98,    99,    99,   142,   142,   143,   143,    63,   128,
   105,   105,    86,    86,    10,    10,    13,    13,    12,    12,
   110,   109,   109,    14,   197,    14,   100,   100,   101,   101,
   102,   102,   102,   102,     3,     3,     3,     4,     4,     4,
     4,     5,     5,     5,    11,    11,   145,   145,   146,   146,
   154,   154,   159,   159,   137,   138,   161,   161,   161,   176,
   176,   155,   155,    81,   108,
    }, yyLen = {
//yyLen 655
     2,     0,     2,     2,     1,     1,     3,     2,     1,     4,
     0,     6,     3,     2,     1,     1,     3,     2,     1,     0,
     5,     0,     4,     3,     3,     3,     2,     3,     3,     3,
     3,     3,     4,     1,     3,     3,     3,     1,     3,     3,
     6,     5,     5,     5,     5,     3,     1,     3,     1,     1,
     3,     3,     3,     2,     1,     1,     1,     1,     1,     4,
     3,     1,     2,     3,     4,     5,     4,     5,     2,     2,
     2,     2,     2,     1,     3,     1,     3,     1,     2,     3,
     5,     2,     4,     2,     4,     1,     3,     1,     3,     2,
     3,     1,     3,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     4,     3,     3,     3,     3,
     2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     4,     3,     3,     3,     3,     2,
     1,     1,     1,     2,     1,     3,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     0,     4,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     3,     3,     6,     5,     5,     5,     5,     4,     3,     3,
     3,     2,     2,     3,     3,     3,     3,     3,     3,     4,
     2,     2,     3,     3,     3,     3,     1,     3,     3,     3,
     3,     3,     2,     2,     3,     3,     3,     3,     3,     6,
     1,     1,     1,     1,     1,     3,     3,     1,     1,     2,
     4,     2,     1,     3,     3,     1,     1,     1,     1,     2,
     4,     2,     1,     2,     2,     4,     1,     0,     2,     2,
     2,     1,     1,     2,     3,     4,     1,     1,     3,     4,
     2,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     0,     4,     0,     3,     0,     0,     5,     3,
     3,     2,     3,     3,     1,     4,     3,     1,     5,     4,
     3,     2,     1,     2,     2,     6,     6,     0,     0,     7,
     0,     0,     7,     5,     4,     0,     0,     9,     0,     6,
     0,     7,     0,     5,     0,     0,     7,     0,     0,     9,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     2,     1,     1,     1,     5,     1,     2,     1,     1,
     1,     3,     1,     3,     1,     4,     6,     3,     5,     2,
     4,     1,     3,     4,     2,     2,     1,     2,     0,     6,
     8,     4,     6,     4,     2,     6,     2,     4,     6,     2,
     4,     2,     4,     1,     1,     1,     3,     1,     4,     1,
     4,     1,     3,     1,     1,     0,     0,     4,     4,     1,
     3,     3,     3,     2,     4,     5,     5,     2,     4,     4,
     3,     3,     3,     2,     1,     4,     3,     3,     0,     0,
     4,     0,     0,     4,     5,     1,     1,     6,     0,     1,
     1,     1,     2,     1,     2,     1,     1,     1,     1,     1,
     1,     1,     2,     3,     3,     3,     4,     0,     3,     1,
     2,     4,     0,     3,     4,     4,     0,     3,     0,     3,
     0,     2,     0,     2,     0,     2,     1,     0,     3,     0,
     0,     0,     0,     0,     8,     1,     1,     1,     1,     2,
     1,     1,     1,     1,     3,     1,     2,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     0,     4,     0,
     3,     0,     3,     4,     2,     2,     1,     2,     0,     6,
     8,     4,     6,     4,     6,     2,     4,     6,     2,     4,
     2,     4,     1,     0,     1,     1,     1,     1,     1,     1,
     1,     1,     3,     1,     3,     1,     2,     1,     2,     1,
     1,     3,     1,     3,     1,     1,     2,     1,     3,     3,
     1,     3,     1,     3,     1,     1,     2,     1,     1,     1,
     2,     2,     0,     1,     0,     4,     1,     2,     1,     3,
     3,     2,     4,     2,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     0,     1,     0,     1,     2,     2,     0,     1,     1,     1,
     1,     1,     2,     0,     0,
    }, yyDefRed = {
//yyDefRed 1111
     1,     0,     0,     0,   365,   367,     0,     0,   312,     0,
     0,     0,   337,   340,     0,     0,     0,   362,   363,   368,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   470,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   490,   492,   494,     0,     0,   425,   545,
   546,   517,   520,   518,   519,     0,     0,   467,    61,   302,
     0,   471,   303,   304,     0,   305,   306,   301,   468,    33,
    49,   466,   515,     0,     0,     0,     0,     0,     0,     0,
   309,     0,    57,     0,     0,    87,     0,     4,   307,   308,
     0,     0,    73,     0,     2,     0,     5,     0,     0,     0,
     0,     7,   188,   199,   189,   212,   185,   205,   195,   194,
   215,   216,   210,   193,   192,   187,   213,   217,   218,   197,
   186,   200,   204,   206,   198,   191,   207,   214,   209,     0,
     0,     0,     0,   184,   203,   202,   219,   183,   190,   181,
   182,     0,     0,     0,     0,   138,   523,   522,     0,   525,
   173,   174,   170,   151,   152,   153,   160,   157,   159,   154,
   155,   175,   176,   161,   162,   614,   167,   166,   150,   172,
   169,   168,   164,   165,   158,   156,   148,   171,   149,   177,
   163,   139,   354,     0,   613,   140,   208,   201,   211,   196,
   178,   179,   180,   136,   137,   142,   141,   144,     0,   143,
   145,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   649,   650,     0,     0,     0,   651,     0,
     0,   360,   361,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,   364,     0,     0,   378,   379,     0,     0,   324,     0,
     0,     0,     0,   490,     0,     0,   282,    71,     0,     0,
     0,   618,   286,    72,     0,    69,     0,     0,   443,    68,
     0,   643,     0,     0,    21,     0,     0,     0,   240,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    15,
    14,     0,     0,     0,     0,     0,   268,     0,     0,     0,
   616,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   253,    53,   252,   512,   511,   513,   509,   510,     0,     0,
     0,     0,   477,   486,   334,     0,   482,   488,   472,   451,
   448,   333,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   263,   264,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   262,   261,     0,     0,     0,     0,   451,   433,   636,   637,
     0,     0,     0,     0,   639,   638,     0,     0,    89,     0,
     0,     0,     0,     0,     0,     3,     0,   437,     0,   331,
    70,   527,   526,   528,   529,   531,   530,   532,     0,     0,
     0,     0,   134,     0,     0,   310,   352,     0,   355,   634,
   635,   357,   146,     0,     0,     0,   370,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,   652,
     0,     0,     0,   516,     0,     0,     0,     0,   345,   621,
   293,   289,     0,   623,     0,     0,   283,   291,     0,   284,
     0,   326,     0,   288,   278,   277,     0,     0,     0,     0,
   330,    52,    23,    25,    24,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   319,    13,     0,
     0,   315,     0,   322,     0,   647,   269,     0,   271,   323,
   617,     0,    91,     0,     0,     0,     0,     0,   499,   497,
   514,   496,   493,   473,   491,   474,   475,   495,     0,     0,
   579,   576,   575,   574,   577,   585,   594,     0,     0,   605,
   604,   609,   608,   595,   580,     0,     0,     0,   602,   429,
   426,     0,     0,   572,   592,     0,   556,   583,   578,     0,
     0,     0,     0,     0,     0,     0,   452,     0,   449,    27,
    28,    29,    30,    31,    50,    51,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   440,     0,   442,     0,     0,   629,
     0,     0,   630,   441,     0,   627,   628,     0,    48,     0,
     0,     0,    45,   228,     0,     0,     0,     0,    38,   220,
    35,   292,     0,     0,     0,     0,    90,    34,    36,   296,
     0,    39,   221,     6,   448,    63,     0,   131,     0,   133,
   547,   348,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,   313,     0,   371,     0,     0,     0,     0,     0,
     0,     0,     0,   344,   373,   338,   372,   341,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   620,     0,     0,
     0,   290,   619,   325,   644,     0,     0,   274,   329,    22,
     0,     9,    32,     0,   227,     0,     0,    16,     0,     0,
     0,     0,     0,     0,     0,     0,     0,   500,     0,   476,
   479,     0,   484,     0,     0,     0,   380,     0,   382,     0,
     0,   606,   610,     0,   570,     0,     0,   565,     0,   568,
     0,   554,   596,     0,   555,   586,     0,   481,     0,   485,
     0,   447,     0,   446,     0,     0,   432,     0,     0,   439,
     0,     0,     0,     0,     0,   276,     0,   438,   275,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    88,
     0,     0,     0,     0,     0,     0,     0,     0,   135,     0,
     0,   615,     0,     0,     0,   358,   147,   460,     0,     0,
   461,     0,   366,    12,   465,    10,     0,   374,     0,   376,
     0,     0,     0,     0,     0,     0,     0,   343,     0,     0,
     0,     0,     0,     0,   622,   295,   285,     0,   328,     0,
   318,   270,    92,     0,   501,   505,   506,   507,   498,   508,
   478,   480,   487,     0,     0,     0,     0,   582,     0,     0,
     0,   557,   581,     0,     0,   427,     0,     0,   584,     0,
   603,     0,   593,   611,     0,   598,   483,   489,   417,     0,
   415,     0,   414,     0,     0,    44,   225,    43,   226,    67,
     0,   645,    41,   223,    42,   224,    65,   436,   435,    47,
     0,     0,     0,     0,     0,     0,     0,     0,     0,    60,
     0,     0,     0,   445,   353,     0,     0,     0,     0,     0,
     0,   463,   464,     0,     0,   335,   377,     0,   336,   294,
     0,     0,     0,   346,     0,    20,   502,   381,     0,     0,
     0,   383,   428,     0,     0,   571,     0,     0,     0,   563,
     0,   561,     0,   566,   569,   553,     0,     0,     0,   413,
   590,     0,     0,   396,     0,   600,     0,     0,     0,   453,
   450,     0,     0,    40,     0,     0,     0,   548,   349,   550,
   356,   552,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   462,     0,
     0,     0,   455,   454,   456,   339,   342,     0,   503,     0,
     0,     0,     0,   423,     0,   421,   424,   431,   430,     0,
     0,     0,     0,     0,   411,     0,     0,   406,     0,   394,
     0,   409,   416,   395,     0,     0,     0,     0,     0,   351,
     0,     0,     0,     0,     0,     0,    11,     0,     0,     0,
     0,     0,     0,   420,   564,     0,   559,   562,   567,     0,
   397,   418,     0,     0,   591,     0,     0,     0,   601,   321,
     0,     0,   359,     0,     0,     0,     0,     0,   457,   375,
   347,     0,     0,   422,     0,     0,   412,     0,   403,     0,
   401,   393,     0,   407,   410,     0,     0,     0,   504,   560,
     0,     0,     0,     0,   405,     0,   399,   402,   408,     0,
   400,
    }, yyDgoto = {
//yyDgoto 198
     1,   346,    67,    68,   690,   614,   615,   206,   432,   554,
   555,   441,   556,   557,   193,    69,    70,    71,    72,    73,
   349,   348,    74,   532,   351,    75,    76,   731,    77,    78,
   433,    79,    80,    81,    82,   648,   443,   444,   307,   308,
    84,    85,    86,    87,   309,   227,   299,   817,  1003,   818,
   920,    89,   484,   813,   616,   661,   285,    90,   777,    91,
    92,   638,   639,   558,   208,   848,   229,   559,   560,   957,
   880,   881,   803,   640,    94,    95,   278,   458,   809,   315,
   230,   310,   486,   539,   538,   561,   562,   737,   573,   574,
    98,    99,   744,  1024,  1060,   861,   564,   960,   961,   565,
   321,   487,   281,   100,   523,   962,   476,   282,   477,   751,
   566,   419,   397,   655,   577,   575,   101,   102,   671,   231,
   209,   210,   567,  1014,   858,   865,   354,   312,   965,   266,
   488,   738,   739,  1015,   195,   568,   395,   481,   771,   104,
   105,   106,   569,   570,   571,   664,   406,   862,   107,   108,
   109,   110,   820,     2,   236,   237,   923,   505,   495,   482,
   669,   516,   286,   211,   313,   314,   718,   447,   239,   685,
   830,   240,   831,   695,  1007,   795,   448,   793,   665,   438,
   667,   668,   918,   355,   745,   578,   764,   576,   762,   728,
   727,   844,   936,  1008,  1049,   794,   804,   437,
    }, yySindex = {
//yySindex 1111
     0,     0, 20312, 21611,     0,     0, 19677, 20067,     0, 22772,
 22772, 18888,     0,     0,  3986, 20701, 20701,     0,     0,     0,
  -145,  -113,     0,     0,     0,     0,    56, 19937,   227,  -103,
   -68,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0, 22901, 22901,   916,    -5, 20442,     0, 21091, 21481, 19156,
 22901, 23030, 19807,     0,     0,     0,   300,   314,     0,     0,
     0,     0,     0,     0,     0,   344,   353,     0,     0,     0,
   -52,     0,     0,     0,  -127,     0,     0,     0,     0,     0,
     0,     0,     0,  1564,  -116,  4977,     0,   114,   671,   456,
     0,   352,     0,    48,   365,     0,   442,     0,     0,     0,
 23288,   483,     0,   258,     0,   166,     0,  -172, 20701, 23417,
 23546,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   264,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   582,     0,
     0, 20572,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,   317, 20572,  -116,   113,   896,   368,
   621,   370,   113,     0,     0,   166,   413,   644,     0, 22772,
 22772,     0,     0,  -145,  -113,     0,     0,     0,     0,   377,
   227,     0,     0,     0,     0,     0,     0,     0,     0,   916,
   412,     0,   993,     0,     0,     0,   448,  -172,     0, 22901,
 22901, 22901, 22901,     0, 22901,  4977,     0,     0,   395,   696,
   698,     0,     0,     0, 17269,     0, 20701, 20701,     0,     0,
 19022,     0, 22772,   -77,     0, 21869, 20312, 20572,     0,  1025,
   427,   432,   422, 21740,     0, 20442,   409,   166,  1564,     0,
     0,     0,   227,   227, 21740,   419,     0,   148,   160,   395,
     0,   404,   160,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   460, 23675,  1041,     0,   728,
     0,     0,     0,     0,     0,     0,     0,     0,   817,   876,
   895,  1082,     0,     0,     0,  2469,     0,     0,     0,     0,
     0,     0, 22772, 22772, 22772, 22772, 21740, 22772, 22772, 22901,
 22901, 22901, 22901, 22901,     0,     0, 22901, 22901, 22901, 22901,
 22901, 22901, 22901, 22901, 22901, 22901, 22901, 22901, 22901, 22901,
     0,     0, 22901, 22901, 22901, 22901,     0,     0,     0,     0,
  3469, 20701,  6356, 22901,     0,     0, 24517, 23030,     0, 21998,
 20442, 19290,   737, 21998, 23030,     0, 19419,     0,   441,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
 22772,   -58,     0,   433,  1066,     0,     0, 22772,     0,     0,
     0,     0,     0,   537,   536,   422,     0, 20572,   538,  6867,
 20701,  7286, 22901, 22901, 22901, 20572,   413, 22127,   539,     0,
    70,    70,   466,     0,     0,  7364, 20701,  7420,     0,     0,
     0,     0,  1037,     0, 22901, 20831,     0,     0, 21221,     0,
   227,     0,   478,     0,     0,     0,   764,   779,   227,    52,
     0,     0,     0,     0,     0, 20067, 22772,  4977,   461,   463,
  6867,  7286, 22901, 22901,  1564,   471,   227,     0,     0, 19548,
     0,     0,  1564,     0, 21351,     0,     0, 21481,     0,     0,
     0,     0,     0,   791, 24013, 20701, 24069, 23675,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,  1162,    22,
     0,     0,     0,     0,     0,     0,     0,  1204,  2298,     0,
     0,     0,     0,     0,     0,   540,   549,   800,     0,     0,
     0,   814,   816,     0,     0,   819,     0,     0,     0,   563,
   828, 22901,   812,  1272,   321,   610,     0,   518,     0,     0,
     0,     0,     0,     0,     0,     0,   427,  2899,  2899,  2899,
  2899,  3875,  3401,  2899,  2899,  2996,  2996,   959,   959,   427,
  1698,   427,   427,   -79,   -79,  1251,  1251,  7787,  2912,   612,
   548,     0,   554,  -113,     0,     0,     0,   227,   556,     0,
   557,  -113,     0,     0,  2912,     0,     0,  -113,     0,   590,
  4492,  1071,     0,     0,    48,   837, 22901,  4492,     0,     0,
     0,     0,   855,   227, 23675,   860,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,  -116,     0,     0,     0,
     0,     0, 24125, 20701, 24181, 20572,    52,   578, 20197, 20067,
 22256,   367,     0,   -82,     0,   584,   585,   227,   591,   592,
   656,   664,    69,     0,     0,     0,     0,     0,     0,     0,
  -113,   227,     0,     0,  -113, 22772, 22901,     0, 22901,   395,
   698,     0,     0,     0,     0, 20831, 21221,     0,     0,     0,
    52,     0,     0,   427,     0, 20312,     0,     0,   227,   160,
 23675,     0,     0,   227,     0,     0,   791,     0,  1131,     0,
     0,   211,     0,   901,  1204,   711,     0,   892,     0,   227,
   227,     0,     0,  2834,     0,  -174,  2298,     0,  2298,     0,
  -106,     0,     0,   382,     0,     0, 22901,     0,   241,     0,
   905,     0,   -92,     0,   -92,   880,     0, 23030, 23030,     0,
   441,   606,   608, 23030, 23030,     0,   441,     0,     0,   114,
  -127, 21740, 22901, 24237, 20701, 24293, 23030,     0, 22385,     0,
   791, 23675,   596,   166, 22772, 20572,     0,     0,     0,   227,
   690,     0,  2298, 20572,  2298,     0,     0,     0,     0,   616,
     0, 20572,     0,     0,     0,     0, 22772,     0,   697,     0,
 20572, 22901, 22901,   629, 22901, 22901,   707,     0, 22514, 20572,
 20572, 20572,     0,    70,     0,     0,     0,   928,     0,   617,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   227,  1313,   940,  1623,     0,   643,   930,
   949,     0,     0, 20572, 20572,     0,   950,   954,     0,   960,
     0,   949,     0,     0,   828,     0,     0,     0,     0,   982,
     0, 20572,     0, 20572, 22901,     0,     0,     0,     0,     0,
 23030,     0,     0,     0,     0,     0,     0,     0,     0,     0,
  4977,   548,   554,   227,   556,   557, 22901,     0,   791,     0,
 20572,   166,   741,     0,     0,   227,   745,   166,   578, 23804,
   113,     0,     0, 20572,   113,     0,     0, 22901,     0,     0,
   383,   749,   754,     0, 21221,     0,     0,     0,   983,  1313,
   932,     0,     0,  1463,  2834,     0,   773,   665,  2834,     0,
  2298,     0,  2834,     0,     0,     0,  1001,   227,  1003,     0,
     0,  1008,  1016,     0,   703,     0,   828, 23933,  1002,     0,
     0,  4977,  4977,     0,   606,     0,   807,     0,     0,     0,
     0,     0, 20572,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,   769,  1096,     0,     0, 20572,
   801, 20572,     0,     0,     0,     0,     0, 20572,     0,  1313,
   983,  1313,  1036,     0,   259,     0,     0,     0,     0,   949,
  1046,   949,   949,  2834,     0,   726,  2298,     0,  -106,     0,
  2298,     0,     0,     0,     0,     0,   784,  1148, 23933,     0,
   831,     0, 24349, 20701, 24405,   537,     0,   -82,   834, 20572,
   983,  1313,  1463,     0,     0,  2834,     0,     0,     0,  1052,
     0,     0,  1056,  1058,     0,   828,  1061,  1052,     0,     0,
 24461,  1148,     0,     0,     0,   227,     0,     0,     0,     0,
     0,   721,   983,     0,   949,  2834,     0,  2834,     0,  2298,
     0,     0,  2834,     0,     0,     0,     0,     0,     0,     0,
  1052,  1068,  1052,  1052,     0,  2834,     0,     0,     0,  1052,
     0,
    }, yyRindex = {
//yyRindex 1111
     0,     0,   168,     0,     0,     0,     0,     0,     0,     0,
     0,   848,     0,     0,     0, 11166, 11270,     0,     0,     0,
  5223,  4761, 12643, 12752, 12944, 13053, 23159,     0, 22643,     0,
     0, 13130, 13245, 13431,  5554,  3753, 13546, 13623,  5685, 13732,
     0,     0,     0,     0,     0,   144, 18753,   775,   760,   120,
     0,     0,  1276,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
 10432,     0,     0,     0, 10554,     0,     0,     0,     0,     0,
     0,     0,     0,    35,  1572, 16903, 10738, 16945,     0, 13929,
     0, 16987,     0, 14038,     0,     0,     0,     0,     0,     0,
   175,     0,     0,     0,     0,    43,     0, 20961, 11382,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,  2855,
  3359,  3863,  4367,     0,     0,     0,     0,     0,     0,     0,
     0,  4850,  5312,  5795,  5842,     0,     0,     0,  6299,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,  8826,     0,
     0,   587,  8290,  8412,  8596,  8718,  8902,  9024,  9208,  2614,
  9330,  9514,  2745,  9636,     0,   144,  1966,     0,     0, 10126,
     0,     0,     0,     0,     0,   848,     0,   857,     0,     0,
     0,     0,     0, 10860,  9820,   835,   981,  1086,  1510,     0,
   786,  1548,  1686,  2066,  4917,  2160,  2373,  5379,  2402,     0,
     0,     0,     0,  3032,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,  1206,     0,     0, 16731,  1853,
  1853,     0,     0,     0,   787,     0,     0,   163,     0,     0,
   787,     0,     0,     0,     0,     0,    79,    79,     0,     0,
 11688, 11044, 14113,     0, 18215,   144,     0,  2105,   207,     0,
     0,   199,   787,   787,     0,     0,     0,   797,   797,     0,
     0,     0,   788,  1985,  2421,  2526,  5745,  6192,  6696,  7200,
   856,  7704,  8499,   942,  8807,     0,     0,     0,  8812,   274,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,  -161,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
  2208, 11518,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,    39,     0,     0,     0,     0,     0,     0,     0,     0,
   144,   316,   639,     0,     0,     0,    77,     0, 12888,     0,
     0,     0,     0,     0,     0,     0,     0,     0, 17401, 17539,
     0,     0,     0, 18350,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   494,     0, 10248,     0,   682, 18081,     0,
    39,     0,     0,     0,     0,    80,     0,     0,     0,     0,
     0,     0,     0,     0,  3405,     0,    39,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
   787,     0,     0,     0,     0,     0,    46,    46,   787,   787,
     0,     0,     0,     0,     0,     0,     0, 16297,     0,     0,
     0,     0,     0,     0,   547,     0,   787,     0,     0,  2371,
   599,     0,   189,     0,   804,     0,     0,  -163,     0,     0,
     0,  9089,     0,   669,     0,    39,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,   151,     0,
     0,     0,     0,     0,     0,    74,     0,    28,     0,     0,
     0,    28,    28,     0,     0,   224,     0,     0,     0,    78,
   224,   209,   348,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0, 11824,  2397, 15503, 15589,
 15676, 15763, 16037, 15849, 15951, 16123, 16211, 14636, 14757, 11933,
 14884, 12050, 12176, 14228, 14419, 14986, 15101,  1092, 15230,     0,
  6058,  4126,  7570, 20961,     0,  4257,     0,   823,  6189,     0,
  6562,  5092,     0,     0, 15374,     0,     0,  7943,     0,  1457,
 16643,     0,     0,     0, 14534,     0,     0,  8520,     0,     0,
     0,     0,     0,   787,     0,   700,     0,     0,     0,     0,
  2094,     0,     0,     0,     0,     0,   212,     0, 17945,     0,
     0,     0,     0,    39,     0,   587,   787,  1030,     0,     0,
   513,   894,     0,   894,     0,  3118,  4630,   823,  3249,  3622,
   894,     0,     0,     0,     0,     0,     0,     0,  5941,   604,
     0,   823,  6445,  6818,  9942,     0,     0,     0,     0, 16817,
  1853,     0,     0,     0,     0,   150,   195,     0,     0,     0,
   787,     0,     0, 12293,     0,    79,   185,     0,   787,   797,
     0,  1022,  1914,   823,  1765,  2070,   716,     0,     0,     0,
     0,     0,     0,     0,     0,   203,     0,   210,     0,   787,
   -11,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0, 18484,     0, 18619,     0,     0,     0,     0,     0,
 16774, 12402,     0,     0,     0,     0, 16860,     0,     0, 17047,
 11632,     0,     0,     0,    39,     0,     0, 17090,     0,     0,
   776,     0,     0,     0,     0,   587, 17673, 17811,     0,   823,
     0,     0,   213,   587,   222,     0,     0,     0,   576,   183,
     0,   346,     0,     0,     0,     0,     0,     0,     0,     0,
   346,     0,     0,  8074,     0,     0,     0,     0,     0,    88,
   346,   346,   858,     0,     0,     0,     0,    46,     0,     0,
     0,     0,     0,  1488,     0,     0,     0,     0,     0,     0,
     0,     0,     0,   787,     0,   245,     0,     0,     0,   214,
    28,     0,     0,   587,    79,     0,    28,    28,     0,    28,
     0,    28,     0,     0,   224,     0,     0,     0,     0,    15,
     0,   587,     0,    79,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
 16383,  6693,  7701,   823,  7066,  7197,     0, 17173,   832,     0,
   587,     0,     0,     0,     0,   787,     0,     0,  1030,     0,
     0,     0,     0,    97,     0,     0,     0,     0,     0,     0,
   894,     0,     0,     0,   197,     0,     0,     0,   248,     0,
   251,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,   124,    15,   124,     0,
     0,   130,   124,     0,     0,     0,   130,   104,   105,     0,
     0, 16471, 16557,     0, 12538, 17227,     0,     0,     0,     0,
     0,     0,   587,  1275,  1388,  1427,  1468,  2244,  2383,  2389,
   526,  2487,  2497,  1123,  2509,     0,     0,  8457,     0,   587,
   894,   682,     0,     0,     0,     0,     0,   346,     0,     0,
   276,     0,   279,     0,   272,     0,     0,     0,     0,    28,
    28,    28,    28,     0,     0,     0,   132,     0,     0,     0,
     0,     0,     0,     0,  1700,  2092,     0,   106,     0,     0,
     0,  8497,     0,    39,     0,   494,     0,   894,     0,    26,
   280,     0,     0,     0,     0,     0,     0,     0,     0,   124,
     0,     0,   124,   124,     0,   130,   124,   124,     0,     0,
     0,   107,     0,  1300,  1587,   823,  1610,  2182,     0,     0,
     0,     0,   282,     0,    28,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,  2295,  1722,   634,     0,     0,
   124,   124,   124,   124,     0,     0,     0,     0,     0,   124,
     0,
    }, yyGindex = {
//yyGindex 198
     0,     0,    -1,     0,  -324,     0,    17,     7,  -334,     3,
     0,     0,     0,  -123,     0,     0,     0,  1089,     0,     0,
   891,  1121,     0,  -225,     0,     0,     0,   603,     0,    14,
  1069,  -252,   -20,     0,    57,     0,   257,   243,     0,    16,
   240,  1304,    -7,    38,   674,    81,     1,  -613,     0,   149,
     0,     0,   813,   202,    34,     0,   -12,  1198,   588,     0,
     0,  -199,   387,  -673,     0,     0,   262,  -449,     0,     0,
     0,   464,   309,  -343,   -80,    11,  1469,  -434,     0,     0,
   336,   609,    89,     0,     0,  -114,   487,   162,     0,     0,
     0,     0,  -442,  2176,   355,  -330,   485,   223,     0,     0,
     0,    24,  -444,     0,  -446,   226,  -266,  -410,     0,  -540,
   642,   -73,   458,  -429,   627,   861,  1248,    18,   230,   660,
     0,     5,  -566,     0,  -773,     0,     0,  -138,  -895,     0,
  -354,  -770,   552,   219,     0,  -822,  1216,   535,  -640,  -263,
     0,    25,     0,   118,  1764,   -83,     0,  -291,  1516,  1907,
     0,     0,   636,     0,    83,   174,     0,     0,     0,   -26,
     0,  -261,     0,     0,     0,     0,     0,  -205,     0,  -432,
     0,     0,     0,     0,     0,     0,    47,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,
    };
    protected static final short[] yyTable = YyTables.yyTable();
    protected static final short[] yyCheck = YyTables.yyCheck();

  /** maps symbol value to printable name.
      @see #yyExpecting
    */
  protected static final String[] yyNames = {
    "end-of-file",null,null,null,null,null,null,null,null,null,"'\\n'",
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,"' '",null,null,null,null,null,
    null,null,null,null,null,null,"','",null,null,null,null,null,null,
    null,null,null,null,null,null,null,"':'","';'",null,"'='",null,"'?'",
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,
    "'['",null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,null,
    null,null,null,null,null,null,null,null,null,null,null,null,null,
"class","module","def","undef",
"begin","rescue","ensure","end",
"if","unless","then","elsif",
"else","case","when","while",
"until","for","break","next",
"redo","retry","in","do",
"do (for condition)","do (for block)","return","yield",
"super","self","nil","true",
"false","and","or","not",
"if (modifier)","unless (modifier)","while (modifier)","until (modifier)",
"rescue (modifier)","alias","defined","BEGIN",
"END","__LINE__","__FILE__",
"__ENCODING__","do (for lambda)","tIDENTIFIER","tFID",
    "tGVAR","tIVAR","tCONSTANT","tCVAR","tLABEL","tCHAR","unary+",
"unary-","tUMINUS_NUM","**","<=>","==","===","!=",">=",
"<=","&&","||","=~","!~","'.'","..","...",
"[]","[]=","<<",">>","&.","::",":: at EXPR_BEG",
    "tOP_ASGN","=>","'('","'('","')'","( arg",
"'['","']'","'{'","{ arg","'*'","'*'","'&'",
"'&'","'`'","'%'","'/'","'+'","'-'","'<'","'>'",
"'|'","'!'","'^'","'{'","'}'","'`'","tSYMBEG",
    "tSTRING_BEG","tXSTRING_BEG","tREGEXP_BEG","tWORDS_BEG","tQWORDS_BEG",
    "tSTRING_DBEG","tSTRING_DVAR","tSTRING_END","->","tLAMBEG",
    "tNTH_REF","tBACK_REF","tSTRING_CONTENT","tINTEGER","tIMAGINARY",
    "tFLOAT","tRATIONAL","tREGEXP_END","tSYMBOLS_BEG","tQSYMBOLS_BEG",
"**arg","tSTRING_DEND","tLABEL_END","tLOWEST",
    };

  /** printable rules for debugging.
    */
  protected static final String [] yyRule = {
    "$accept : program",
    "$$1 :",
    "program : $$1 top_compstmt",
    "top_compstmt : top_stmts opt_terms",
    "top_stmts : none",
    "top_stmts : top_stmt",
    "top_stmts : top_stmts terms top_stmt",
    "top_stmts : error top_stmt",
    "top_stmt : stmt",
    "top_stmt : keyword_BEGIN tLCURLY top_compstmt tRCURLY",
    "$$2 :",
    "bodystmt : compstmt opt_rescue k_else $$2 compstmt opt_ensure",
    "bodystmt : compstmt opt_rescue opt_ensure",
    "compstmt : stmts opt_terms",
    "stmts : none",
    "stmts : stmt_or_begin",
    "stmts : stmts terms stmt_or_begin",
    "stmts : error stmt",
    "stmt_or_begin : stmt",
    "$$3 :",
    "stmt_or_begin : keyword_begin $$3 tLCURLY top_compstmt tRCURLY",
    "$$4 :",
    "stmt : keyword_alias fitem $$4 fitem",
    "stmt : keyword_alias tGVAR tGVAR",
    "stmt : keyword_alias tGVAR tBACK_REF",
    "stmt : keyword_alias tGVAR tNTH_REF",
    "stmt : keyword_undef undef_list",
    "stmt : stmt modifier_if expr_value",
    "stmt : stmt modifier_unless expr_value",
    "stmt : stmt modifier_while expr_value",
    "stmt : stmt modifier_until expr_value",
    "stmt : stmt modifier_rescue stmt",
    "stmt : keyword_END tLCURLY compstmt tRCURLY",
    "stmt : command_asgn",
    "stmt : mlhs '=' command_call",
    "stmt : lhs '=' mrhs",
    "stmt : mlhs '=' mrhs_arg",
    "stmt : expr",
    "command_asgn : lhs '=' command_rhs",
    "command_asgn : var_lhs tOP_ASGN command_rhs",
    "command_asgn : primary_value '[' opt_call_args rbracket tOP_ASGN command_rhs",
    "command_asgn : primary_value call_op tIDENTIFIER tOP_ASGN command_rhs",
    "command_asgn : primary_value call_op tCONSTANT tOP_ASGN command_rhs",
    "command_asgn : primary_value tCOLON2 tCONSTANT tOP_ASGN command_rhs",
    "command_asgn : primary_value tCOLON2 tIDENTIFIER tOP_ASGN command_rhs",
    "command_asgn : backref tOP_ASGN command_rhs",
    "command_rhs : command_call",
    "command_rhs : command_call modifier_rescue stmt",
    "command_rhs : command_asgn",
    "expr : command_call",
    "expr : expr keyword_and expr",
    "expr : expr keyword_or expr",
    "expr : keyword_not opt_nl expr",
    "expr : tBANG command_call",
    "expr : arg",
    "expr_value : expr",
    "command_call : command",
    "command_call : block_command",
    "block_command : block_call",
    "block_command : block_call call_op2 operation2 command_args",
    "cmd_brace_block : tLBRACE_ARG brace_body tRCURLY",
    "fcall : operation",
    "command : fcall command_args",
    "command : fcall command_args cmd_brace_block",
    "command : primary_value call_op operation2 command_args",
    "command : primary_value call_op operation2 command_args cmd_brace_block",
    "command : primary_value tCOLON2 operation2 command_args",
    "command : primary_value tCOLON2 operation2 command_args cmd_brace_block",
    "command : keyword_super command_args",
    "command : keyword_yield command_args",
    "command : k_return call_args",
    "command : keyword_break call_args",
    "command : keyword_next call_args",
    "mlhs : mlhs_basic",
    "mlhs : tLPAREN mlhs_inner rparen",
    "mlhs_inner : mlhs_basic",
    "mlhs_inner : tLPAREN mlhs_inner rparen",
    "mlhs_basic : mlhs_head",
    "mlhs_basic : mlhs_head mlhs_item",
    "mlhs_basic : mlhs_head tSTAR mlhs_node",
    "mlhs_basic : mlhs_head tSTAR mlhs_node ',' mlhs_post",
    "mlhs_basic : mlhs_head tSTAR",
    "mlhs_basic : mlhs_head tSTAR ',' mlhs_post",
    "mlhs_basic : tSTAR mlhs_node",
    "mlhs_basic : tSTAR mlhs_node ',' mlhs_post",
    "mlhs_basic : tSTAR",
    "mlhs_basic : tSTAR ',' mlhs_post",
    "mlhs_item : mlhs_node",
    "mlhs_item : tLPAREN mlhs_inner rparen",
    "mlhs_head : mlhs_item ','",
    "mlhs_head : mlhs_head mlhs_item ','",
    "mlhs_post : mlhs_item",
    "mlhs_post : mlhs_post ',' mlhs_item",
    "mlhs_node : tIDENTIFIER",
    "mlhs_node : tIVAR",
    "mlhs_node : tGVAR",
    "mlhs_node : tCONSTANT",
    "mlhs_node : tCVAR",
    "mlhs_node : keyword_nil",
    "mlhs_node : keyword_self",
    "mlhs_node : keyword_true",
    "mlhs_node : keyword_false",
    "mlhs_node : keyword__FILE__",
    "mlhs_node : keyword__LINE__",
    "mlhs_node : keyword__ENCODING__",
    "mlhs_node : primary_value '[' opt_call_args rbracket",
    "mlhs_node : primary_value call_op tIDENTIFIER",
    "mlhs_node : primary_value tCOLON2 tIDENTIFIER",
    "mlhs_node : primary_value call_op tCONSTANT",
    "mlhs_node : primary_value tCOLON2 tCONSTANT",
    "mlhs_node : tCOLON3 tCONSTANT",
    "mlhs_node : backref",
    "lhs : tIDENTIFIER",
    "lhs : tIVAR",
    "lhs : tGVAR",
    "lhs : tCONSTANT",
    "lhs : tCVAR",
    "lhs : keyword_nil",
    "lhs : keyword_self",
    "lhs : keyword_true",
    "lhs : keyword_false",
    "lhs : keyword__FILE__",
    "lhs : keyword__LINE__",
    "lhs : keyword__ENCODING__",
    "lhs : primary_value '[' opt_call_args rbracket",
    "lhs : primary_value call_op tIDENTIFIER",
    "lhs : primary_value tCOLON2 tIDENTIFIER",
    "lhs : primary_value call_op tCONSTANT",
    "lhs : primary_value tCOLON2 tCONSTANT",
    "lhs : tCOLON3 tCONSTANT",
    "lhs : backref",
    "cname : tIDENTIFIER",
    "cname : tCONSTANT",
    "cpath : tCOLON3 cname",
    "cpath : cname",
    "cpath : primary_value tCOLON2 cname",
    "fname : tIDENTIFIER",
    "fname : tCONSTANT",
    "fname : tFID",
    "fname : op",
    "fname : reswords",
    "fsym : fname",
    "fsym : symbol",
    "fitem : fsym",
    "fitem : dsym",
    "undef_list : fitem",
    "$$5 :",
    "undef_list : undef_list ',' $$5 fitem",
    "op : tPIPE",
    "op : tCARET",
    "op : tAMPER2",
    "op : tCMP",
    "op : tEQ",
    "op : tEQQ",
    "op : tMATCH",
    "op : tNMATCH",
    "op : tGT",
    "op : tGEQ",
    "op : tLT",
    "op : tLEQ",
    "op : tNEQ",
    "op : tLSHFT",
    "op : tRSHFT",
    "op : tDSTAR",
    "op : tPLUS",
    "op : tMINUS",
    "op : tSTAR2",
    "op : tSTAR",
    "op : tDIVIDE",
    "op : tPERCENT",
    "op : tPOW",
    "op : tBANG",
    "op : tTILDE",
    "op : tUPLUS",
    "op : tUMINUS",
    "op : tAREF",
    "op : tASET",
    "op : tBACK_REF2",
    "reswords : keyword__LINE__",
    "reswords : keyword__FILE__",
    "reswords : keyword__ENCODING__",
    "reswords : keyword_BEGIN",
    "reswords : keyword_END",
    "reswords : keyword_alias",
    "reswords : keyword_and",
    "reswords : keyword_begin",
    "reswords : keyword_break",
    "reswords : keyword_case",
    "reswords : keyword_class",
    "reswords : keyword_def",
    "reswords : keyword_defined",
    "reswords : keyword_do",
    "reswords : keyword_else",
    "reswords : keyword_elsif",
    "reswords : keyword_end",
    "reswords : keyword_ensure",
    "reswords : keyword_false",
    "reswords : keyword_for",
    "reswords : keyword_in",
    "reswords : keyword_module",
    "reswords : keyword_next",
    "reswords : keyword_nil",
    "reswords : keyword_not",
    "reswords : keyword_or",
    "reswords : keyword_redo",
    "reswords : keyword_rescue",
    "reswords : keyword_retry",
    "reswords : keyword_return",
    "reswords : keyword_self",
    "reswords : keyword_super",
    "reswords : keyword_then",
    "reswords : keyword_true",
    "reswords : keyword_undef",
    "reswords : keyword_when",
    "reswords : keyword_yield",
    "reswords : keyword_if",
    "reswords : keyword_unless",
    "reswords : keyword_while",
    "reswords : keyword_until",
    "reswords : modifier_rescue",
    "arg : lhs '=' arg_rhs",
    "arg : var_lhs tOP_ASGN arg_rhs",
    "arg : primary_value '[' opt_call_args rbracket tOP_ASGN arg",
    "arg : primary_value call_op tIDENTIFIER tOP_ASGN arg_rhs",
    "arg : primary_value call_op tCONSTANT tOP_ASGN arg_rhs",
    "arg : primary_value tCOLON2 tIDENTIFIER tOP_ASGN arg_rhs",
    "arg : primary_value tCOLON2 tCONSTANT tOP_ASGN arg_rhs",
    "arg : tCOLON3 tCONSTANT tOP_ASGN arg_rhs",
    "arg : backref tOP_ASGN arg_rhs",
    "arg : arg tDOT2 arg",
    "arg : arg tDOT3 arg",
    "arg : arg tDOT2",
    "arg : arg tDOT3",
    "arg : arg tPLUS arg",
    "arg : arg tMINUS arg",
    "arg : arg tSTAR2 arg",
    "arg : arg tDIVIDE arg",
    "arg : arg tPERCENT arg",
    "arg : arg tPOW arg",
    "arg : tUMINUS_NUM simple_numeric tPOW arg",
    "arg : tUPLUS arg",
    "arg : tUMINUS arg",
    "arg : arg tPIPE arg",
    "arg : arg tCARET arg",
    "arg : arg tAMPER2 arg",
    "arg : arg tCMP arg",
    "arg : rel_expr",
    "arg : arg tEQ arg",
    "arg : arg tEQQ arg",
    "arg : arg tNEQ arg",
    "arg : arg tMATCH arg",
    "arg : arg tNMATCH arg",
    "arg : tBANG arg",
    "arg : tTILDE arg",
    "arg : arg tLSHFT arg",
    "arg : arg tRSHFT arg",
    "arg : arg tANDOP arg",
    "arg : arg tOROP arg",
    "arg : keyword_defined opt_nl arg",
    "arg : arg '?' arg opt_nl ':' arg",
    "arg : primary",
    "relop : tGT",
    "relop : tLT",
    "relop : tGEQ",
    "relop : tLEQ",
    "rel_expr : arg relop arg",
    "rel_expr : rel_expr relop arg",
    "arg_value : arg",
    "aref_args : none",
    "aref_args : args trailer",
    "aref_args : args ',' assocs trailer",
    "aref_args : assocs trailer",
    "arg_rhs : arg",
    "arg_rhs : arg modifier_rescue arg",
    "paren_args : tLPAREN2 opt_call_args rparen",
    "opt_paren_args : none",
    "opt_paren_args : paren_args",
    "opt_call_args : none",
    "opt_call_args : call_args",
    "opt_call_args : args ','",
    "opt_call_args : args ',' assocs ','",
    "opt_call_args : assocs ','",
    "call_args : command",
    "call_args : args opt_block_arg",
    "call_args : assocs opt_block_arg",
    "call_args : args ',' assocs opt_block_arg",
    "call_args : block_arg",
    "$$6 :",
    "command_args : $$6 call_args",
    "block_arg : tAMPER arg_value",
    "opt_block_arg : ',' block_arg",
    "opt_block_arg : none_block_pass",
    "args : arg_value",
    "args : tSTAR arg_value",
    "args : args ',' arg_value",
    "args : args ',' tSTAR arg_value",
    "mrhs_arg : mrhs",
    "mrhs_arg : arg_value",
    "mrhs : args ',' arg_value",
    "mrhs : args ',' tSTAR arg_value",
    "mrhs : tSTAR arg_value",
    "primary : literal",
    "primary : strings",
    "primary : xstring",
    "primary : regexp",
    "primary : words",
    "primary : qwords",
    "primary : symbols",
    "primary : qsymbols",
    "primary : var_ref",
    "primary : backref",
    "primary : tFID",
    "$$7 :",
    "primary : keyword_begin $$7 bodystmt keyword_end",
    "$$8 :",
    "primary : tLPAREN_ARG $$8 rparen",
    "$$9 :",
    "$$10 :",
    "primary : tLPAREN_ARG $$9 stmt $$10 rparen",
    "primary : tLPAREN compstmt tRPAREN",
    "primary : primary_value tCOLON2 tCONSTANT",
    "primary : tCOLON3 tCONSTANT",
    "primary : tLBRACK aref_args tRBRACK",
    "primary : tLBRACE assoc_list tRCURLY",
    "primary : k_return",
    "primary : keyword_yield tLPAREN2 call_args rparen",
    "primary : keyword_yield tLPAREN2 rparen",
    "primary : keyword_yield",
    "primary : keyword_defined opt_nl tLPAREN2 expr rparen",
    "primary : keyword_not tLPAREN2 expr rparen",
    "primary : keyword_not tLPAREN2 rparen",
    "primary : fcall brace_block",
    "primary : method_call",
    "primary : method_call brace_block",
    "primary : tLAMBDA lambda",
    "primary : keyword_if expr_value then compstmt if_tail keyword_end",
    "primary : keyword_unless expr_value then compstmt opt_else keyword_end",
    "$$11 :",
    "$$12 :",
    "primary : keyword_while $$11 expr_value do $$12 compstmt keyword_end",
    "$$13 :",
    "$$14 :",
    "primary : keyword_until $$13 expr_value do $$14 compstmt keyword_end",
    "primary : keyword_case expr_value opt_terms case_body keyword_end",
    "primary : keyword_case opt_terms case_body keyword_end",
    "$$15 :",
    "$$16 :",
    "primary : keyword_for for_var keyword_in $$15 expr_value do $$16 compstmt keyword_end",
    "$$17 :",
    "primary : k_class cpath superclass $$17 bodystmt keyword_end",
    "$$18 :",
    "primary : k_class tLSHFT expr $$18 term bodystmt keyword_end",
    "$$19 :",
    "primary : k_module cpath $$19 bodystmt keyword_end",
    "$$20 :",
    "$$21 :",
    "primary : keyword_def fname $$20 $$21 f_arglist bodystmt keyword_end",
    "$$22 :",
    "$$23 :",
    "primary : keyword_def singleton dot_or_colon $$22 fname $$23 f_arglist bodystmt keyword_end",
    "primary : keyword_break",
    "primary : keyword_next",
    "primary : keyword_redo",
    "primary : keyword_retry",
    "primary_value : primary",
    "k_class : keyword_class",
    "k_else : keyword_else",
    "k_module : keyword_module",
    "k_return : keyword_return",
    "then : term",
    "then : keyword_then",
    "then : term keyword_then",
    "do : term",
    "do : keyword_do_cond",
    "if_tail : opt_else",
    "if_tail : keyword_elsif expr_value then compstmt if_tail",
    "opt_else : none",
    "opt_else : k_else compstmt",
    "for_var : lhs",
    "for_var : mlhs",
    "f_marg : f_norm_arg",
    "f_marg : tLPAREN f_margs rparen",
    "f_marg_list : f_marg",
    "f_marg_list : f_marg_list ',' f_marg",
    "f_margs : f_marg_list",
    "f_margs : f_marg_list ',' tSTAR f_norm_arg",
    "f_margs : f_marg_list ',' tSTAR f_norm_arg ',' f_marg_list",
    "f_margs : f_marg_list ',' tSTAR",
    "f_margs : f_marg_list ',' tSTAR ',' f_marg_list",
    "f_margs : tSTAR f_norm_arg",
    "f_margs : tSTAR f_norm_arg ',' f_marg_list",
    "f_margs : tSTAR",
    "f_margs : tSTAR ',' f_marg_list",
    "block_args_tail : f_block_kwarg ',' f_kwrest opt_f_block_arg",
    "block_args_tail : f_block_kwarg opt_f_block_arg",
    "block_args_tail : f_kwrest opt_f_block_arg",
    "block_args_tail : f_block_arg",
    "opt_block_args_tail : ',' block_args_tail",
    "opt_block_args_tail :",
    "block_param : f_arg ',' f_block_optarg ',' f_rest_arg opt_block_args_tail",
    "block_param : f_arg ',' f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail",
    "block_param : f_arg ',' f_block_optarg opt_block_args_tail",
    "block_param : f_arg ',' f_block_optarg ',' f_arg opt_block_args_tail",
    "block_param : f_arg ',' f_rest_arg opt_block_args_tail",
    "block_param : f_arg ','",
    "block_param : f_arg ',' f_rest_arg ',' f_arg opt_block_args_tail",
    "block_param : f_arg opt_block_args_tail",
    "block_param : f_block_optarg ',' f_rest_arg opt_block_args_tail",
    "block_param : f_block_optarg ',' f_rest_arg ',' f_arg opt_block_args_tail",
    "block_param : f_block_optarg opt_block_args_tail",
    "block_param : f_block_optarg ',' f_arg opt_block_args_tail",
    "block_param : f_rest_arg opt_block_args_tail",
    "block_param : f_rest_arg ',' f_arg opt_block_args_tail",
    "block_param : block_args_tail",
    "opt_block_param : none",
    "opt_block_param : block_param_def",
    "block_param_def : tPIPE opt_bv_decl tPIPE",
    "block_param_def : tOROP",
    "block_param_def : tPIPE block_param opt_bv_decl tPIPE",
    "opt_bv_decl : opt_nl",
    "opt_bv_decl : opt_nl ';' bv_decls opt_nl",
    "bv_decls : bvar",
    "bv_decls : bv_decls ',' bvar",
    "bvar : tIDENTIFIER",
    "bvar : f_bad_arg",
    "$$24 :",
    "$$25 :",
    "lambda : $$24 f_larglist $$25 lambda_body",
    "f_larglist : tLPAREN2 f_args opt_bv_decl tRPAREN",
    "f_larglist : f_args",
    "lambda_body : tLAMBEG compstmt tRCURLY",
    "lambda_body : keyword_do_lambda bodystmt keyword_end",
    "do_block : keyword_do_block do_body keyword_end",
    "block_call : command do_block",
    "block_call : block_call call_op2 operation2 opt_paren_args",
    "block_call : block_call call_op2 operation2 opt_paren_args brace_block",
    "block_call : block_call call_op2 operation2 command_args do_block",
    "method_call : fcall paren_args",
    "method_call : primary_value call_op operation2 opt_paren_args",
    "method_call : primary_value tCOLON2 operation2 paren_args",
    "method_call : primary_value tCOLON2 operation3",
    "method_call : primary_value call_op paren_args",
    "method_call : primary_value tCOLON2 paren_args",
    "method_call : keyword_super paren_args",
    "method_call : keyword_super",
    "method_call : primary_value '[' opt_call_args rbracket",
    "brace_block : tLCURLY brace_body tRCURLY",
    "brace_block : keyword_do do_body keyword_end",
    "$$26 :",
    "$$27 :",
    "brace_body : $$26 $$27 opt_block_param compstmt",
    "$$28 :",
    "$$29 :",
    "do_body : $$28 $$29 opt_block_param bodystmt",
    "case_body : keyword_when args then compstmt cases",
    "cases : opt_else",
    "cases : case_body",
    "opt_rescue : keyword_rescue exc_list exc_var then compstmt opt_rescue",
    "opt_rescue :",
    "exc_list : arg_value",
    "exc_list : mrhs",
    "exc_list : none",
    "exc_var : tASSOC lhs",
    "exc_var : none",
    "opt_ensure : keyword_ensure compstmt",
    "opt_ensure : none",
    "literal : numeric",
    "literal : symbol",
    "literal : dsym",
    "strings : string",
    "string : tCHAR",
    "string : string1",
    "string : string string1",
    "string1 : tSTRING_BEG string_contents tSTRING_END",
    "xstring : tXSTRING_BEG xstring_contents tSTRING_END",
    "regexp : tREGEXP_BEG regexp_contents tREGEXP_END",
    "words : tWORDS_BEG ' ' word_list tSTRING_END",
    "word_list :",
    "word_list : word_list word ' '",
    "word : string_content",
    "word : word string_content",
    "symbols : tSYMBOLS_BEG ' ' symbol_list tSTRING_END",
    "symbol_list :",
    "symbol_list : symbol_list word ' '",
    "qwords : tQWORDS_BEG ' ' qword_list tSTRING_END",
    "qsymbols : tQSYMBOLS_BEG ' ' qsym_list tSTRING_END",
    "qword_list :",
    "qword_list : qword_list tSTRING_CONTENT ' '",
    "qsym_list :",
    "qsym_list : qsym_list tSTRING_CONTENT ' '",
    "string_contents :",
    "string_contents : string_contents string_content",
    "xstring_contents :",
    "xstring_contents : xstring_contents string_content",
    "regexp_contents :",
    "regexp_contents : regexp_contents string_content",
    "string_content : tSTRING_CONTENT",
    "$$30 :",
    "string_content : tSTRING_DVAR $$30 string_dvar",
    "$$31 :",
    "$$32 :",
    "$$33 :",
    "$$34 :",
    "$$35 :",
    "string_content : tSTRING_DBEG $$31 $$32 $$33 $$34 $$35 compstmt tSTRING_DEND",
    "string_dvar : tGVAR",
    "string_dvar : tIVAR",
    "string_dvar : tCVAR",
    "string_dvar : backref",
    "symbol : tSYMBEG sym",
    "sym : fname",
    "sym : tIVAR",
    "sym : tGVAR",
    "sym : tCVAR",
    "dsym : tSYMBEG xstring_contents tSTRING_END",
    "numeric : simple_numeric",
    "numeric : tUMINUS_NUM simple_numeric",
    "simple_numeric : tINTEGER",
    "simple_numeric : tFLOAT",
    "simple_numeric : tRATIONAL",
    "simple_numeric : tIMAGINARY",
    "var_ref : tIDENTIFIER",
    "var_ref : tIVAR",
    "var_ref : tGVAR",
    "var_ref : tCONSTANT",
    "var_ref : tCVAR",
    "var_ref : keyword_nil",
    "var_ref : keyword_self",
    "var_ref : keyword_true",
    "var_ref : keyword_false",
    "var_ref : keyword__FILE__",
    "var_ref : keyword__LINE__",
    "var_ref : keyword__ENCODING__",
    "var_lhs : tIDENTIFIER",
    "var_lhs : tIVAR",
    "var_lhs : tGVAR",
    "var_lhs : tCONSTANT",
    "var_lhs : tCVAR",
    "var_lhs : keyword_nil",
    "var_lhs : keyword_self",
    "var_lhs : keyword_true",
    "var_lhs : keyword_false",
    "var_lhs : keyword__FILE__",
    "var_lhs : keyword__LINE__",
    "var_lhs : keyword__ENCODING__",
    "backref : tNTH_REF",
    "backref : tBACK_REF",
    "$$36 :",
    "superclass : tLT $$36 expr_value term",
    "superclass :",
    "f_arglist : tLPAREN2 f_args rparen",
    "$$37 :",
    "f_arglist : $$37 f_args term",
    "args_tail : f_kwarg ',' f_kwrest opt_f_block_arg",
    "args_tail : f_kwarg opt_f_block_arg",
    "args_tail : f_kwrest opt_f_block_arg",
    "args_tail : f_block_arg",
    "opt_args_tail : ',' args_tail",
    "opt_args_tail :",
    "f_args : f_arg ',' f_optarg ',' f_rest_arg opt_args_tail",
    "f_args : f_arg ',' f_optarg ',' f_rest_arg ',' f_arg opt_args_tail",
    "f_args : f_arg ',' f_optarg opt_args_tail",
    "f_args : f_arg ',' f_optarg ',' f_arg opt_args_tail",
    "f_args : f_arg ',' f_rest_arg opt_args_tail",
    "f_args : f_arg ',' f_rest_arg ',' f_arg opt_args_tail",
    "f_args : f_arg opt_args_tail",
    "f_args : f_optarg ',' f_rest_arg opt_args_tail",
    "f_args : f_optarg ',' f_rest_arg ',' f_arg opt_args_tail",
    "f_args : f_optarg opt_args_tail",
    "f_args : f_optarg ',' f_arg opt_args_tail",
    "f_args : f_rest_arg opt_args_tail",
    "f_args : f_rest_arg ',' f_arg opt_args_tail",
    "f_args : args_tail",
    "f_args :",
    "f_bad_arg : tCONSTANT",
    "f_bad_arg : tIVAR",
    "f_bad_arg : tGVAR",
    "f_bad_arg : tCVAR",
    "f_norm_arg : f_bad_arg",
    "f_norm_arg : tIDENTIFIER",
    "f_arg_asgn : f_norm_arg",
    "f_arg_item : f_arg_asgn",
    "f_arg_item : tLPAREN f_margs rparen",
    "f_arg : f_arg_item",
    "f_arg : f_arg ',' f_arg_item",
    "f_label : tLABEL",
    "f_kw : f_label arg_value",
    "f_kw : f_label",
    "f_block_kw : f_label primary_value",
    "f_block_kw : f_label",
    "f_block_kwarg : f_block_kw",
    "f_block_kwarg : f_block_kwarg ',' f_block_kw",
    "f_kwarg : f_kw",
    "f_kwarg : f_kwarg ',' f_kw",
    "kwrest_mark : tPOW",
    "kwrest_mark : tDSTAR",
    "f_kwrest : kwrest_mark tIDENTIFIER",
    "f_kwrest : kwrest_mark",
    "f_opt : f_arg_asgn '=' arg_value",
    "f_block_opt : f_arg_asgn '=' primary_value",
    "f_block_optarg : f_block_opt",
    "f_block_optarg : f_block_optarg ',' f_block_opt",
    "f_optarg : f_opt",
    "f_optarg : f_optarg ',' f_opt",
    "restarg_mark : tSTAR2",
    "restarg_mark : tSTAR",
    "f_rest_arg : restarg_mark tIDENTIFIER",
    "f_rest_arg : restarg_mark",
    "blkarg_mark : tAMPER2",
    "blkarg_mark : tAMPER",
    "f_block_arg : blkarg_mark tIDENTIFIER",
    "opt_f_block_arg : ',' f_block_arg",
    "opt_f_block_arg :",
    "singleton : var_ref",
    "$$38 :",
    "singleton : tLPAREN2 $$38 expr rparen",
    "assoc_list : none",
    "assoc_list : assocs trailer",
    "assocs : assoc",
    "assocs : assocs ',' assoc",
    "assoc : arg_value tASSOC arg_value",
    "assoc : tLABEL arg_value",
    "assoc : tSTRING_BEG string_contents tLABEL_END arg_value",
    "assoc : tDSTAR arg_value",
    "operation : tIDENTIFIER",
    "operation : tCONSTANT",
    "operation : tFID",
    "operation2 : tIDENTIFIER",
    "operation2 : tCONSTANT",
    "operation2 : tFID",
    "operation2 : op",
    "operation3 : tIDENTIFIER",
    "operation3 : tFID",
    "operation3 : op",
    "dot_or_colon : tDOT",
    "dot_or_colon : tCOLON2",
    "call_op : tDOT",
    "call_op : tANDDOT",
    "call_op2 : call_op",
    "call_op2 : tCOLON2",
    "opt_terms :",
    "opt_terms : terms",
    "opt_nl :",
    "opt_nl : '\\n'",
    "rparen : opt_nl tRPAREN",
    "rbracket : opt_nl tRBRACK",
    "trailer :",
    "trailer : '\\n'",
    "trailer : ','",
    "term : ';'",
    "term : '\\n'",
    "terms : term",
    "terms : terms ';'",
    "none :",
    "none_block_pass :",
    };

  protected org.jruby.parser.YYDebug yydebug;

  /** index-checked interface to {@link #yyNames}.
      @param token single character or <tt>%token</tt> value.
      @return token name or <tt>[illegal]</tt> or <tt>[unknown]</tt>.
    */
  public static String yyName (int token) {
    if (token < 0 || token > yyNames.length) return "[illegal]";
    String name;
    if ((name = yyNames[token]) != null) return name;
    return "[unknown]";
  }


  /** computes list of expected tokens on error by tracing the tables.
      @param state for which to compute the list.
      @return list of token names.
    */
  protected String[] yyExpecting (int state) {
    int token, n, len = 0;
    boolean[] ok = new boolean[yyNames.length];

    if ((n = yySindex[state]) != 0)
      for (token = n < 0 ? -n : 0;
           token < yyNames.length && n+token < yyTable.length; ++ token)
        if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
          ++ len;
          ok[token] = true;
        }
    if ((n = yyRindex[state]) != 0)
      for (token = n < 0 ? -n : 0;
           token < yyNames.length && n+token < yyTable.length; ++ token)
        if (yyCheck[n+token] == token && !ok[token] && yyNames[token] != null) {
          ++ len;
          ok[token] = true;
        }

    String result[] = new String[len];
    for (n = token = 0; n < len;  ++ token)
      if (ok[token]) result[n++] = yyNames[token];
    return result;
  }

  /** the generated parser, with debugging messages.
      Maintains a dynamic state and value stack.
      @param yyLex scanner.
      @param ayydebug debug message writer implementing <tt>yyDebug</tt>, or <tt>null</tt>.
      @return result of the last reduction, if any.
    */
  public Object yyparse (RubyLexer yyLex, Object ayydebug)
				throws java.io.IOException {
    this.yydebug = (org.jruby.parser.YYDebug) ayydebug;
    return yyparse(yyLex);
  }

  /** initial size and increment of the state/value stack [default 256].
      This is not final so that it can be overwritten outside of invocations
      of {@link #yyparse}.
    */
  protected int yyMax;

  /** executed at the beginning of a reduce action.
      Used as <tt>$$ = yyDefault($1)</tt>, prior to the user-specified action, if any.
      Can be overwritten to provide deep copy, etc.
      @param first value for <tt>$1</tt>, or <tt>null</tt>.
      @return first.
    */
  protected Object yyDefault (Object first) {
    return first;
  }

  /** the generated parser.
      Maintains a dynamic state and value stack.
      @param yyLex scanner.
      @return result of the last reduction, if any.
    */
  public Object yyparse (RubyLexer yyLex) throws java.io.IOException {
    if (yyMax <= 0) yyMax = 256;			// initial size
    int yyState = 0, yyStates[] = new int[yyMax];	// state stack
    Object yyVal = null, yyVals[] = new Object[yyMax];	// value stack
    int yyToken = -1;					// current input
    int yyErrorFlag = 0;				// #tokens to shift

    yyLoop: for (int yyTop = 0;; ++ yyTop) {
      if (yyTop >= yyStates.length) {			// dynamically increase
        int[] i = new int[yyStates.length+yyMax];
        System.arraycopy(yyStates, 0, i, 0, yyStates.length);
        yyStates = i;
        Object[] o = new Object[yyVals.length+yyMax];
        System.arraycopy(yyVals, 0, o, 0, yyVals.length);
        yyVals = o;
      }
      yyStates[yyTop] = yyState;
      yyVals[yyTop] = yyVal;
      if (yydebug != null) yydebug.push(yyState, yyVal);

      yyDiscarded: for (;;) {	// discarding a token does not change stack
        int yyN;
        if ((yyN = yyDefRed[yyState]) == 0) {	// else [default] reduce (yyN)
          if (yyToken < 0) {
//            yyToken = yyLex.advance() ? yyLex.token() : 0;
            yyToken = yyLex.nextToken();
            if (yydebug != null)
              yydebug.lex(yyState, yyToken, yyName(yyToken), yyLex.value());
          }
          if ((yyN = yySindex[yyState]) != 0 && (yyN += yyToken) >= 0
              && yyN < yyTable.length && yyCheck[yyN] == yyToken) {
            if (yydebug != null)
              yydebug.shift(yyState, yyTable[yyN], yyErrorFlag-1);
            yyState = yyTable[yyN];		// shift to yyN
            yyVal = yyLex.value();
            yyToken = -1;
            if (yyErrorFlag > 0) -- yyErrorFlag;
            continue yyLoop;
          }
          if ((yyN = yyRindex[yyState]) != 0 && (yyN += yyToken) >= 0
              && yyN < yyTable.length && yyCheck[yyN] == yyToken)
            yyN = yyTable[yyN];			// reduce (yyN)
          else
            switch (yyErrorFlag) {
  
            case 0:
              support.yyerror("syntax error", yyExpecting(yyState), yyNames[yyToken]);
              if (yydebug != null) yydebug.error("syntax error");
  
            case 1: case 2:
              yyErrorFlag = 3;
              do {
                if ((yyN = yySindex[yyStates[yyTop]]) != 0
                    && (yyN += yyErrorCode) >= 0 && yyN < yyTable.length
                    && yyCheck[yyN] == yyErrorCode) {
                  if (yydebug != null)
                    yydebug.shift(yyStates[yyTop], yyTable[yyN], 3);
                  yyState = yyTable[yyN];
                  yyVal = yyLex.value();
                  continue yyLoop;
                }
                if (yydebug != null) yydebug.pop(yyStates[yyTop]);
              } while (-- yyTop >= 0);
              if (yydebug != null) yydebug.reject();
              support.yyerror("irrecoverable syntax error");
  
            case 3:
              if (yyToken == 0) {
                if (yydebug != null) yydebug.reject();
                support.yyerror("irrecoverable syntax error at end-of-file");
              }
              if (yydebug != null)
                yydebug.discard(yyState, yyToken, yyName(yyToken),
  							yyLex.value());
              yyToken = -1;
              continue yyDiscarded;		// leave stack alone
            }
        }
        int yyV = yyTop + 1-yyLen[yyN];
        if (yydebug != null)
          yydebug.reduce(yyState, yyStates[yyV-1], yyN, yyRule[yyN], yyLen[yyN]);
        ParserState state = states[yyN];
        if (state == null) {
            yyVal = yyDefault(yyV > yyTop ? null : yyVals[yyV]);
        } else {
            yyVal = state.execute(support, lexer, yyVal, yyVals, yyTop);
        }
//        switch (yyN) {
// ACTIONS_BEGIN
case 1:
					// line 380 "RubyParser.y"
  {
                  lexer.setState(EXPR_BEG);
                  support.initTopLocalVariables();
              }
  break;
case 2:
					// line 383 "RubyParser.y"
  {
                  if (((Node)yyVals[0+yyTop]) != null && !support.getConfiguration().isEvalParse()) {
                      /* last expression should not be void */
                      if (((Node)yyVals[0+yyTop]) instanceof BlockNode) {
                          support.void_expr(((BlockNode)yyVals[0+yyTop]).getLast());
                      } else {
                          support.void_expr(((Node)yyVals[0+yyTop]));
                      }
                  }
                  support.getResult().setAST(support.addRootNode(((Node)yyVals[0+yyTop])));
              }
  break;
case 3:
					// line 395 "RubyParser.y"
  {
                  yyVal = support.void_stmts(((Node)yyVals[-1+yyTop]));
              }
  break;
case 5:
					// line 400 "RubyParser.y"
  {
                  yyVal = support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop])));
              }
  break;
case 6:
					// line 403 "RubyParser.y"
  {
                  yyVal = support.appendToBlock(((Node)yyVals[-2+yyTop]), support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop]))));
              }
  break;
case 7:
					// line 406 "RubyParser.y"
  {
                  yyVal = ((Node)yyVals[0+yyTop]);
              }
  break;
case 9:
					// line 411 "RubyParser.y"
  {
                    support.getResult().addBeginNode(new PreExe19Node(((Integer)yyVals[-3+yyTop]), support.getCurrentScope(), ((Node)yyVals[-1+yyTop]), lexer.getRubySourceline()));
                    yyVal = null;
              }
  break;
case 10:
					// line 416 "RubyParser.y"
  {
                   if (((RescueBodyNode)yyVals[-1+yyTop]) == null) support.yyerror("else without rescue is useless"); 
               }
  break;
case 11:
					// line 418 "RubyParser.y"
  {
                   yyVal = support.new_bodystmt(((Node)yyVals[-5+yyTop]), ((RescueBodyNode)yyVals[-4+yyTop]), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 12:
					// line 421 "RubyParser.y"
  {
                    yyVal = support.new_bodystmt(((Node)yyVals[-2+yyTop]), ((RescueBodyNode)yyVals[-1+yyTop]), null, ((Node)yyVals[0+yyTop]));
                }
  break;
case 13:
					// line 425 "RubyParser.y"
  {
                    yyVal = support.void_stmts(((Node)yyVals[-1+yyTop]));
                }
  break;
case 15:
					// line 430 "RubyParser.y"
  {
                    yyVal = support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop])));
                }
  break;
case 16:
					// line 433 "RubyParser.y"
  {
                    yyVal = support.appendToBlock(((Node)yyVals[-2+yyTop]), support.newline_node(((Node)yyVals[0+yyTop]), support.getPosition(((Node)yyVals[0+yyTop]))));
                }
  break;
case 17:
					// line 436 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 18:
					// line 440 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 19:
					// line 444 "RubyParser.y"
  {
                   support.yyerror("BEGIN is permitted only at toplevel");
                }
  break;
case 20:
					// line 446 "RubyParser.y"
  {
                    yyVal = new BeginNode(((Integer)yyVals[-4+yyTop]), support.makeNullNil(((Node)yyVals[-3+yyTop])));
                }
  break;
case 21:
					// line 450 "RubyParser.y"
  {
                    lexer.setState(EXPR_FNAME|EXPR_FITEM);
                }
  break;
case 22:
					// line 452 "RubyParser.y"
  {
                    yyVal = ParserSupport.newAlias(((Integer)yyVals[-3+yyTop]), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 23:
					// line 455 "RubyParser.y"
  {
                    yyVal = new VAliasNode(((Integer)yyVals[-2+yyTop]), support.symbolID(((ByteList)yyVals[-1+yyTop])), support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 24:
					// line 458 "RubyParser.y"
  {
                    yyVal = new VAliasNode(((Integer)yyVals[-2+yyTop]), support.symbolID(((ByteList)yyVals[-1+yyTop])), support.symbolID(((BackRefNode)yyVals[0+yyTop]).getByteName()));
                }
  break;
case 25:
					// line 461 "RubyParser.y"
  {
                    support.yyerror("can't make alias for the number variables");
                }
  break;
case 26:
					// line 464 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 27:
					// line 467 "RubyParser.y"
  {
                    yyVal = support.new_if(support.getPosition(((Node)yyVals[-2+yyTop])), support.cond(((Node)yyVals[0+yyTop])), ((Node)yyVals[-2+yyTop]), null);
                    support.fixpos(((Node)yyVal), ((Node)yyVals[0+yyTop]));
                }
  break;
case 28:
					// line 471 "RubyParser.y"
  {
                    yyVal = support.new_if(support.getPosition(((Node)yyVals[-2+yyTop])), support.cond(((Node)yyVals[0+yyTop])), null, ((Node)yyVals[-2+yyTop]));
                    support.fixpos(((Node)yyVal), ((Node)yyVals[0+yyTop]));
                }
  break;
case 29:
					// line 475 "RubyParser.y"
  {
                    if (((Node)yyVals[-2+yyTop]) != null && ((Node)yyVals[-2+yyTop]) instanceof BeginNode) {
                        yyVal = new WhileNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.cond(((Node)yyVals[0+yyTop])), ((BeginNode)yyVals[-2+yyTop]).getBodyNode(), false);
                    } else {
                        yyVal = new WhileNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.cond(((Node)yyVals[0+yyTop])), ((Node)yyVals[-2+yyTop]), true);
                    }
                }
  break;
case 30:
					// line 482 "RubyParser.y"
  {
                    if (((Node)yyVals[-2+yyTop]) != null && ((Node)yyVals[-2+yyTop]) instanceof BeginNode) {
                        yyVal = new UntilNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.cond(((Node)yyVals[0+yyTop])), ((BeginNode)yyVals[-2+yyTop]).getBodyNode(), false);
                    } else {
                        yyVal = new UntilNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.cond(((Node)yyVals[0+yyTop])), ((Node)yyVals[-2+yyTop]), true);
                    }
                }
  break;
case 31:
					// line 489 "RubyParser.y"
  {
                    yyVal = support.newRescueModNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 32:
					// line 492 "RubyParser.y"
  {
                    if (support.isInDef()) {
                       support.warn(ID.END_IN_METHOD, ((Integer)yyVals[-3+yyTop]), "END in method; use at_exit");
                    }
                    yyVal = new PostExeNode(((Integer)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]), lexer.getRubySourceline());
                }
  break;
case 34:
					// line 499 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = node_assign(((MultipleAsgnNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 35:
					// line 503 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = node_assign(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 36:
					// line 507 "RubyParser.y"
  {
                    yyVal = node_assign(((MultipleAsgnNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 38:
					// line 512 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = node_assign(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 39:
					// line 516 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_op_assign(((AssignableNode)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 40:
					// line 520 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_ary_op_assign(((Node)yyVals[-5+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 41:
					// line 524 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_attr_op_assign(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 42:
					// line 528 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_attr_op_assign(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 43:
					// line 532 "RubyParser.y"
  {
                    int line = ((Node)yyVals[-4+yyTop]).getLine();
                    yyVal = support.new_const_op_assign(line, support.new_colon2(line, ((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop])), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 44:
					// line 537 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_attr_op_assign(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 45:
					// line 541 "RubyParser.y"
  {
                    support.backrefAssignError(((Node)yyVals[-2+yyTop]));
                }
  break;
case 46:
					// line 545 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 47:
					// line 549 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[-2+yyTop]));
                    yyVal = support.newRescueModNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 50:
					// line 558 "RubyParser.y"
  {
                    yyVal = support.newAndNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 51:
					// line 561 "RubyParser.y"
  {
                    yyVal = support.newOrNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 52:
					// line 564 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(support.method_cond(((Node)yyVals[0+yyTop])), lexer.BANG);
                }
  break;
case 53:
					// line 567 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(support.method_cond(((Node)yyVals[0+yyTop])), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 55:
					// line 572 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                }
  break;
case 59:
					// line 582 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 60:
					// line 587 "RubyParser.y"
  {
                    yyVal = ((IterNode)yyVals[-1+yyTop]);
                }
  break;
case 61:
					// line 591 "RubyParser.y"
  {
                    yyVal = support.new_fcall(((ByteList)yyVals[0+yyTop]));
                }
  break;
case 62:
					// line 596 "RubyParser.y"
  {
                    support.frobnicate_fcall_args(((FCallNode)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                    yyVal = ((FCallNode)yyVals[-1+yyTop]);
                }
  break;
case 63:
					// line 600 "RubyParser.y"
  {
                    support.frobnicate_fcall_args(((FCallNode)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));
                    yyVal = ((FCallNode)yyVals[-2+yyTop]);
                }
  break;
case 64:
					// line 604 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 65:
					// line 607 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop])); 
                }
  break;
case 66:
					// line 610 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 67:
					// line 613 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));
                }
  break;
case 68:
					// line 616 "RubyParser.y"
  {
                    yyVal = support.new_super(((Integer)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 69:
					// line 619 "RubyParser.y"
  {
                    yyVal = support.new_yield(((Integer)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 70:
					// line 622 "RubyParser.y"
  {
                    yyVal = new ReturnNode(((Integer)yyVals[-1+yyTop]), support.ret_args(((Node)yyVals[0+yyTop]), ((Integer)yyVals[-1+yyTop])));
                }
  break;
case 71:
					// line 625 "RubyParser.y"
  {
                    yyVal = new BreakNode(((Integer)yyVals[-1+yyTop]), support.ret_args(((Node)yyVals[0+yyTop]), ((Integer)yyVals[-1+yyTop])));
                }
  break;
case 72:
					// line 628 "RubyParser.y"
  {
                    yyVal = new NextNode(((Integer)yyVals[-1+yyTop]), support.ret_args(((Node)yyVals[0+yyTop]), ((Integer)yyVals[-1+yyTop])));
                }
  break;
case 74:
					// line 634 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 75:
					// line 639 "RubyParser.y"
  {
                    yyVal = ((MultipleAsgnNode)yyVals[0+yyTop]);
                }
  break;
case 76:
					// line 642 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((Integer)yyVals[-2+yyTop]), support.newArrayNode(((Integer)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop])), null, null);
                }
  break;
case 77:
					// line 647 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[0+yyTop]).getLine(), ((ListNode)yyVals[0+yyTop]), null, null);
                }
  break;
case 78:
					// line 650 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-1+yyTop]).getLine(), ((ListNode)yyVals[-1+yyTop]).add(((Node)yyVals[0+yyTop])), null, null);
                }
  break;
case 79:
					// line 653 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-2+yyTop]).getLine(), ((ListNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]), (ListNode) null);
                }
  break;
case 80:
					// line 656 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-4+yyTop]).getLine(), ((ListNode)yyVals[-4+yyTop]), ((Node)yyVals[-2+yyTop]), ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 81:
					// line 659 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-1+yyTop]).getLine(), ((ListNode)yyVals[-1+yyTop]), new StarNode(lexer.getRubySourceline()), null);
                }
  break;
case 82:
					// line 662 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), new StarNode(lexer.getRubySourceline()), ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 83:
					// line 665 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((Node)yyVals[0+yyTop]).getLine(), null, ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 84:
					// line 668 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((Node)yyVals[-2+yyTop]).getLine(), null, ((Node)yyVals[-2+yyTop]), ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 85:
					// line 671 "RubyParser.y"
  {
                      yyVal = new MultipleAsgnNode(lexer.getRubySourceline(), null, new StarNode(lexer.getRubySourceline()), null);
                }
  break;
case 86:
					// line 674 "RubyParser.y"
  {
                      yyVal = new MultipleAsgnNode(lexer.getRubySourceline(), null, new StarNode(lexer.getRubySourceline()), ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 88:
					// line 679 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 89:
					// line 684 "RubyParser.y"
  {
                    yyVal = support.newArrayNode(((Node)yyVals[-1+yyTop]).getLine(), ((Node)yyVals[-1+yyTop]));
                }
  break;
case 90:
					// line 687 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]));
                }
  break;
case 91:
					// line 692 "RubyParser.y"
  {
                    yyVal = support.newArrayNode(((Node)yyVals[0+yyTop]).getLine(), ((Node)yyVals[0+yyTop]));
                }
  break;
case 92:
					// line 695 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));
                }
  break;
case 93:
					// line 699 "RubyParser.y"
  {
                    yyVal = support.assignableLabelOrIdentifier(((ByteList)yyVals[0+yyTop]), null);
                }
  break;
case 94:
					// line 702 "RubyParser.y"
  {
                   yyVal = new InstAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 95:
					// line 705 "RubyParser.y"
  {
                   yyVal = new GlobalAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 96:
					// line 708 "RubyParser.y"
  {
                    if (support.isInDef()) support.compile_error("dynamic constant assignment");
                    yyVal = new ConstDeclNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), null, NilImplicitNode.NIL);
                }
  break;
case 97:
					// line 712 "RubyParser.y"
  {
                    yyVal = new ClassVarAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 98:
					// line 715 "RubyParser.y"
  {
                    support.compile_error("Can't assign to nil");
                    yyVal = null;
                }
  break;
case 99:
					// line 719 "RubyParser.y"
  {
                    support.compile_error("Can't change the value of self");
                    yyVal = null;
                }
  break;
case 100:
					// line 723 "RubyParser.y"
  {
                    support.compile_error("Can't assign to true");
                    yyVal = null;
                }
  break;
case 101:
					// line 727 "RubyParser.y"
  {
                    support.compile_error("Can't assign to false");
                    yyVal = null;
                }
  break;
case 102:
					// line 731 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __FILE__");
                    yyVal = null;
                }
  break;
case 103:
					// line 735 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __LINE__");
                    yyVal = null;
                }
  break;
case 104:
					// line 739 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __ENCODING__");
                    yyVal = null;
                }
  break;
case 105:
					// line 743 "RubyParser.y"
  {
                    yyVal = support.aryset(((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));
                }
  break;
case 106:
					// line 746 "RubyParser.y"
  {
                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 107:
					// line 749 "RubyParser.y"
  {
                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 108:
					// line 752 "RubyParser.y"
  {
                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 109:
					// line 755 "RubyParser.y"
  {
                    if (support.isInDef()) support.yyerror("dynamic constant assignment");

                    Integer position = support.getPosition(((Node)yyVals[-2+yyTop]));

                    yyVal = new ConstDeclNode(position, (RubySymbol) null, support.new_colon2(position, ((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 110:
					// line 762 "RubyParser.y"
  {
                    if (support.isInDef()) {
                        support.yyerror("dynamic constant assignment");
                    }

                    Integer position = lexer.tokline;

                    yyVal = new ConstDeclNode(position, (RubySymbol) null, support.new_colon3(position, ((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 111:
					// line 771 "RubyParser.y"
  {
                    support.backrefAssignError(((Node)yyVals[0+yyTop]));
                }
  break;
case 112:
					// line 776 "RubyParser.y"
  {
                    yyVal = support.assignableLabelOrIdentifier(((ByteList)yyVals[0+yyTop]), null);
                }
  break;
case 113:
					// line 779 "RubyParser.y"
  {
                    yyVal = new InstAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 114:
					// line 782 "RubyParser.y"
  {
                    yyVal = new GlobalAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 115:
					// line 785 "RubyParser.y"
  {
                    if (support.isInDef()) support.compile_error("dynamic constant assignment");

                    yyVal = new ConstDeclNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), null, NilImplicitNode.NIL);
                }
  break;
case 116:
					// line 790 "RubyParser.y"
  {
                    yyVal = new ClassVarAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 117:
					// line 793 "RubyParser.y"
  {
                    support.compile_error("Can't assign to nil");
                    yyVal = null;
                }
  break;
case 118:
					// line 797 "RubyParser.y"
  {
                    support.compile_error("Can't change the value of self");
                    yyVal = null;
                }
  break;
case 119:
					// line 801 "RubyParser.y"
  {
                    support.compile_error("Can't assign to true");
                    yyVal = null;
                }
  break;
case 120:
					// line 805 "RubyParser.y"
  {
                    support.compile_error("Can't assign to false");
                    yyVal = null;
                }
  break;
case 121:
					// line 809 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __FILE__");
                    yyVal = null;
                }
  break;
case 122:
					// line 813 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __LINE__");
                    yyVal = null;
                }
  break;
case 123:
					// line 817 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __ENCODING__");
                    yyVal = null;
                }
  break;
case 124:
					// line 821 "RubyParser.y"
  {
                    yyVal = support.aryset(((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));
                }
  break;
case 125:
					// line 824 "RubyParser.y"
  {
                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 126:
					// line 827 "RubyParser.y"
  {
                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 127:
					// line 830 "RubyParser.y"
  {
                    yyVal = support.attrset(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 128:
					// line 833 "RubyParser.y"
  {
                    if (support.isInDef()) {
                        support.yyerror("dynamic constant assignment");
                    }

                    Integer position = support.getPosition(((Node)yyVals[-2+yyTop]));

                    yyVal = new ConstDeclNode(position, (RubySymbol) null, support.new_colon2(position, ((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 129:
					// line 842 "RubyParser.y"
  {
                    if (support.isInDef()) {
                        support.yyerror("dynamic constant assignment");
                    }

                    Integer position = lexer.tokline;

                    yyVal = new ConstDeclNode(position, (RubySymbol) null, support.new_colon3(position, ((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 130:
					// line 851 "RubyParser.y"
  {
                    support.backrefAssignError(((Node)yyVals[0+yyTop]));
                }
  break;
case 131:
					// line 855 "RubyParser.y"
  {
                    support.yyerror("class/module name must be CONSTANT");
                }
  break;
case 132:
					// line 858 "RubyParser.y"
  {
                   yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 133:
					// line 862 "RubyParser.y"
  {
                    yyVal = support.new_colon3(lexer.tokline, ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 134:
					// line 865 "RubyParser.y"
  {
                    yyVal = support.new_colon2(lexer.tokline, null, ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 135:
					// line 868 "RubyParser.y"
  {
                    yyVal = support.new_colon2(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 136:
					// line 873 "RubyParser.y"
  {
                   yyVal = ((ByteList)yyVals[0+yyTop]);
               }
  break;
case 137:
					// line 876 "RubyParser.y"
  {
                   yyVal = ((ByteList)yyVals[0+yyTop]);
               }
  break;
case 138:
					// line 879 "RubyParser.y"
  {
                   yyVal = ((ByteList)yyVals[0+yyTop]);
               }
  break;
case 139:
					// line 882 "RubyParser.y"
  {
                   lexer.setState(EXPR_ENDFN);
                   yyVal = ((ByteList)yyVals[0+yyTop]);
               }
  break;
case 140:
					// line 886 "RubyParser.y"
  {
                   lexer.setState(EXPR_ENDFN);
                   yyVal = ((ByteList)yyVals[0+yyTop]);
               }
  break;
case 141:
					// line 892 "RubyParser.y"
  {
                   yyVal = new LiteralNode(lexer.getRubySourceline(), support.symbolID(((ByteList)yyVals[0+yyTop])));
               }
  break;
case 142:
					// line 895 "RubyParser.y"
  {
                   yyVal = new LiteralNode(lexer.getRubySourceline(), support.symbolID(((ByteList)yyVals[0+yyTop])));
               }
  break;
case 143:
					// line 900 "RubyParser.y"
  {  /* LiteralNode*/
                    yyVal = ((LiteralNode)yyVals[0+yyTop]);
                }
  break;
case 144:
					// line 903 "RubyParser.y"
  {  /* SymbolNode/DSymbolNode*/
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 145:
					// line 907 "RubyParser.y"
  {
                    yyVal = ParserSupport.newUndef(((Node)yyVals[0+yyTop]).getLine(), ((Node)yyVals[0+yyTop]));
                }
  break;
case 146:
					// line 910 "RubyParser.y"
  {
                    lexer.setState(EXPR_FNAME|EXPR_FITEM);
                }
  break;
case 147:
					// line 912 "RubyParser.y"
  {
                    yyVal = support.appendToBlock(((Node)yyVals[-3+yyTop]), ParserSupport.newUndef(((Node)yyVals[-3+yyTop]).getLine(), ((Node)yyVals[0+yyTop])));
                }
  break;
case 148:
					// line 917 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 149:
					// line 920 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 150:
					// line 923 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 151:
					// line 926 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 152:
					// line 929 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 153:
					// line 932 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 154:
					// line 935 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 155:
					// line 938 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 156:
					// line 941 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 157:
					// line 944 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 158:
					// line 947 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 159:
					// line 950 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 160:
					// line 953 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 161:
					// line 956 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 162:
					// line 959 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 163:
					// line 962 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 164:
					// line 965 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 165:
					// line 968 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 166:
					// line 971 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 167:
					// line 974 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 168:
					// line 977 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 169:
					// line 980 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 170:
					// line 983 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 171:
					// line 986 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 172:
					// line 989 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 173:
					// line 992 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 174:
					// line 995 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 175:
					// line 998 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 176:
					// line 1001 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 177:
					// line 1004 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                 }
  break;
case 178:
					// line 1009 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.__LINE__.bytes;
                }
  break;
case 179:
					// line 1012 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.__FILE__.bytes;
                }
  break;
case 180:
					// line 1015 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.__ENCODING__.bytes;
                }
  break;
case 181:
					// line 1018 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.LBEGIN.bytes;
                }
  break;
case 182:
					// line 1021 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.LEND.bytes;
                }
  break;
case 183:
					// line 1024 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.ALIAS.bytes;
                }
  break;
case 184:
					// line 1027 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.AND.bytes;
                }
  break;
case 185:
					// line 1030 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.BEGIN.bytes;
                }
  break;
case 186:
					// line 1033 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.BREAK.bytes;
                }
  break;
case 187:
					// line 1036 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.CASE.bytes;
                }
  break;
case 188:
					// line 1039 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.CLASS.bytes;
                }
  break;
case 189:
					// line 1042 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.DEF.bytes;
                }
  break;
case 190:
					// line 1045 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.DEFINED_P.bytes;
                }
  break;
case 191:
					// line 1048 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.DO.bytes;
                }
  break;
case 192:
					// line 1051 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.ELSE.bytes;
                }
  break;
case 193:
					// line 1054 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.ELSIF.bytes;
                }
  break;
case 194:
					// line 1057 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.END.bytes;
                }
  break;
case 195:
					// line 1060 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.ENSURE.bytes;
                }
  break;
case 196:
					// line 1063 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.FALSE.bytes;
                }
  break;
case 197:
					// line 1066 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.FOR.bytes;
                }
  break;
case 198:
					// line 1069 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.IN.bytes;
                }
  break;
case 199:
					// line 1072 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.MODULE.bytes;
                }
  break;
case 200:
					// line 1075 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.NEXT.bytes;
                }
  break;
case 201:
					// line 1078 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.NIL.bytes;
                }
  break;
case 202:
					// line 1081 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.NOT.bytes;
                }
  break;
case 203:
					// line 1084 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.OR.bytes;
                }
  break;
case 204:
					// line 1087 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.REDO.bytes;
                }
  break;
case 205:
					// line 1090 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.RESCUE.bytes;
                }
  break;
case 206:
					// line 1093 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.RETRY.bytes;
                }
  break;
case 207:
					// line 1096 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.RETURN.bytes;
                }
  break;
case 208:
					// line 1099 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.SELF.bytes;
                }
  break;
case 209:
					// line 1102 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.SUPER.bytes;
                }
  break;
case 210:
					// line 1105 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.THEN.bytes;
                }
  break;
case 211:
					// line 1108 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.TRUE.bytes;
                }
  break;
case 212:
					// line 1111 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.UNDEF.bytes;
                }
  break;
case 213:
					// line 1114 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.WHEN.bytes;
                }
  break;
case 214:
					// line 1117 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.YIELD.bytes;
                }
  break;
case 215:
					// line 1120 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.IF.bytes;
                }
  break;
case 216:
					// line 1123 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.UNLESS.bytes;
                }
  break;
case 217:
					// line 1126 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.WHILE.bytes;
                }
  break;
case 218:
					// line 1129 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.UNTIL.bytes;
                }
  break;
case 219:
					// line 1132 "RubyParser.y"
  {
                    yyVal = RubyLexer.Keyword.RESCUE.bytes;
                }
  break;
case 220:
					// line 1136 "RubyParser.y"
  {
                    yyVal = node_assign(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 221:
					// line 1139 "RubyParser.y"
  {
                    yyVal = support.new_op_assign(((AssignableNode)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 222:
					// line 1142 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_ary_op_assign(((Node)yyVals[-5+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 223:
					// line 1146 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_attr_op_assign(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 224:
					// line 1150 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_attr_op_assign(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 225:
					// line 1154 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.new_attr_op_assign(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 226:
					// line 1158 "RubyParser.y"
  {
                    Integer pos = support.getPosition(((Node)yyVals[-4+yyTop]));
                    yyVal = support.new_const_op_assign(pos, support.new_colon2(pos, ((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-2+yyTop])), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 227:
					// line 1162 "RubyParser.y"
  {
                    Integer pos = lexer.getRubySourceline();
                    yyVal = support.new_const_op_assign(pos, new Colon3Node(pos, support.symbolID(((ByteList)yyVals[-2+yyTop]))), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 228:
					// line 1166 "RubyParser.y"
  {
                    support.backrefAssignError(((Node)yyVals[-2+yyTop]));
                }
  break;
case 229:
					// line 1169 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[-2+yyTop]));
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
    
                    boolean isLiteral = ((Node)yyVals[-2+yyTop]) instanceof FixnumNode && ((Node)yyVals[0+yyTop]) instanceof FixnumNode;
                    yyVal = new DotNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.makeNullNil(((Node)yyVals[-2+yyTop])), support.makeNullNil(((Node)yyVals[0+yyTop])), false, isLiteral);
                }
  break;
case 230:
					// line 1176 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[-2+yyTop]));
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));

                    boolean isLiteral = ((Node)yyVals[-2+yyTop]) instanceof FixnumNode && ((Node)yyVals[0+yyTop]) instanceof FixnumNode;
                    yyVal = new DotNode(support.getPosition(((Node)yyVals[-2+yyTop])), support.makeNullNil(((Node)yyVals[-2+yyTop])), support.makeNullNil(((Node)yyVals[0+yyTop])), true, isLiteral);
                }
  break;
case 231:
					// line 1183 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[-1+yyTop]));

                    boolean isLiteral = ((Node)yyVals[-1+yyTop]) instanceof FixnumNode;
                    yyVal = new DotNode(support.getPosition(((Node)yyVals[-1+yyTop])), support.makeNullNil(((Node)yyVals[-1+yyTop])), NilImplicitNode.NIL, false, isLiteral);
                }
  break;
case 232:
					// line 1189 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[-1+yyTop]));

                    boolean isLiteral = ((Node)yyVals[-1+yyTop]) instanceof FixnumNode;
                    yyVal = new DotNode(support.getPosition(((Node)yyVals[-1+yyTop])), support.makeNullNil(((Node)yyVals[-1+yyTop])), NilImplicitNode.NIL, true, isLiteral);
                }
  break;
case 233:
					// line 1195 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 234:
					// line 1198 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 235:
					// line 1201 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 236:
					// line 1204 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 237:
					// line 1207 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 238:
					// line 1210 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 239:
					// line 1213 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(support.getOperatorCallNode(((NumericNode)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline()), ((ByteList)yyVals[-3+yyTop]));
                }
  break;
case 240:
					// line 1216 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 241:
					// line 1219 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 242:
					// line 1222 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 243:
					// line 1225 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 244:
					// line 1228 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 245:
					// line 1231 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 246:
					// line 1234 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 247:
					// line 1237 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 248:
					// line 1240 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 249:
					// line 1243 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 250:
					// line 1246 "RubyParser.y"
  {
                    yyVal = support.getMatchNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                  /* ENEBO
                        $$ = match_op($1, $3);
                        if (nd_type($1) == NODE_LIT && TYPE($1->nd_lit) == T_REGEXP) {
                            $$ = reg_named_capture_assign($1->nd_lit, $$);
                        }
                  */
                }
  break;
case 251:
					// line 1255 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 252:
					// line 1258 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(support.method_cond(((Node)yyVals[0+yyTop])), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 253:
					// line 1261 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[0+yyTop]), ((ByteList)yyVals[-1+yyTop]));
                }
  break;
case 254:
					// line 1264 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 255:
					// line 1267 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 256:
					// line 1270 "RubyParser.y"
  {
                    yyVal = support.newAndNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 257:
					// line 1273 "RubyParser.y"
  {
                    yyVal = support.newOrNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 258:
					// line 1276 "RubyParser.y"
  {
                    yyVal = new DefinedNode(((Integer)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 259:
					// line 1279 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[-5+yyTop]));
                    yyVal = support.new_if(support.getPosition(((Node)yyVals[-5+yyTop])), support.cond(((Node)yyVals[-5+yyTop])), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 260:
					// line 1283 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 261:
					// line 1287 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 262:
					// line 1290 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 263:
					// line 1293 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 264:
					// line 1296 "RubyParser.y"
  {
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 265:
					// line 1300 "RubyParser.y"
  {
                     yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 266:
					// line 1303 "RubyParser.y"
  {
                     support.warning(ID.MISCELLANEOUS, lexer.getRubySourceline(), "comparison '" + ((ByteList)yyVals[-1+yyTop]) + "' after comparison");
                     yyVal = support.getOperatorCallNode(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), lexer.getRubySourceline());
                }
  break;
case 267:
					// line 1308 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.makeNullNil(((Node)yyVals[0+yyTop]));
                }
  break;
case 269:
					// line 1314 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 270:
					// line 1317 "RubyParser.y"
  {
                    yyVal = support.arg_append(((Node)yyVals[-3+yyTop]), support.remove_duplicate_keys(((HashNode)yyVals[-1+yyTop])));
                }
  break;
case 271:
					// line 1320 "RubyParser.y"
  {
                    yyVal = support.newArrayNode(((HashNode)yyVals[-1+yyTop]).getLine(), support.remove_duplicate_keys(((HashNode)yyVals[-1+yyTop])));
                }
  break;
case 272:
					// line 1324 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 273:
					// line 1328 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[-2+yyTop]));
                    yyVal = support.newRescueModNode(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 274:
					// line 1333 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                    if (yyVal != null) ((Node)yyVal).setLine(((Integer)yyVals[-2+yyTop]));
                }
  break;
case 279:
					// line 1342 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 280:
					// line 1345 "RubyParser.y"
  {
                    yyVal = support.arg_append(((Node)yyVals[-3+yyTop]), support.remove_duplicate_keys(((HashNode)yyVals[-1+yyTop])));
                }
  break;
case 281:
					// line 1348 "RubyParser.y"
  {
                    yyVal = support.newArrayNode(((HashNode)yyVals[-1+yyTop]).getLine(), support.remove_duplicate_keys(((HashNode)yyVals[-1+yyTop])));
                }
  break;
case 282:
					// line 1354 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = support.newArrayNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));
                }
  break;
case 283:
					// line 1358 "RubyParser.y"
  {
                    yyVal = arg_blk_pass(((Node)yyVals[-1+yyTop]), ((BlockPassNode)yyVals[0+yyTop]));
                }
  break;
case 284:
					// line 1361 "RubyParser.y"
  {
                    yyVal = support.newArrayNode(((HashNode)yyVals[-1+yyTop]).getLine(), support.remove_duplicate_keys(((HashNode)yyVals[-1+yyTop])));
                    yyVal = arg_blk_pass(((Node)yyVal), ((BlockPassNode)yyVals[0+yyTop]));
                }
  break;
case 285:
					// line 1365 "RubyParser.y"
  {
                    yyVal = support.arg_append(((Node)yyVals[-3+yyTop]), support.remove_duplicate_keys(((HashNode)yyVals[-1+yyTop])));
                    yyVal = arg_blk_pass(((Node)yyVal), ((BlockPassNode)yyVals[0+yyTop]));
                }
  break;
case 286:
					// line 1369 "RubyParser.y"
  {
                }
  break;
case 287:
					// line 1373 "RubyParser.y"
  {
                    yyVal = Long.valueOf(lexer.getCmdArgumentState().getStack());
                    lexer.getCmdArgumentState().begin();
                }
  break;
case 288:
					// line 1376 "RubyParser.y"
  {
                    lexer.getCmdArgumentState().reset(((Long)yyVals[-1+yyTop]).longValue());
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 289:
					// line 1381 "RubyParser.y"
  {
                    yyVal = new BlockPassNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));
                }
  break;
case 290:
					// line 1385 "RubyParser.y"
  {
                    yyVal = ((BlockPassNode)yyVals[0+yyTop]);
                }
  break;
case 292:
					// line 1391 "RubyParser.y"
  { /* ArrayNode*/
                    int line = ((Node)yyVals[0+yyTop]) instanceof NilImplicitNode ? lexer.getRubySourceline() : ((Node)yyVals[0+yyTop]).getLine();
                    yyVal = support.newArrayNode(line, ((Node)yyVals[0+yyTop]));
                }
  break;
case 293:
					// line 1395 "RubyParser.y"
  { /* SplatNode*/
                    yyVal = support.newSplatNode(((Node)yyVals[0+yyTop]));
                }
  break;
case 294:
					// line 1398 "RubyParser.y"
  { /* ArgsCatNode, SplatNode, ArrayNode*/
                    Node node = support.splat_array(((Node)yyVals[-2+yyTop]));

                    if (node != null) {
                        yyVal = support.list_append(node, ((Node)yyVals[0+yyTop]));
                    } else {
                        yyVal = support.arg_append(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                    }
                }
  break;
case 295:
					// line 1407 "RubyParser.y"
  { /* ArgsCatNode, SplatNode, ArrayNode*/
                    Node node = null;

                    /* FIXME: lose syntactical elements here (and others like this)*/
                    if (((Node)yyVals[0+yyTop]) instanceof ArrayNode &&
                        (node = support.splat_array(((Node)yyVals[-3+yyTop]))) != null) {
                        yyVal = support.list_concat(node, ((Node)yyVals[0+yyTop]));
                    } else {
                        yyVal = ParserSupport.arg_concat(((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));
                    }
                }
  break;
case 296:
					// line 1419 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 297:
					// line 1422 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 298:
					// line 1427 "RubyParser.y"
  {
                    Node node = support.splat_array(((Node)yyVals[-2+yyTop]));

                    if (node != null) {
                        yyVal = support.list_append(node, ((Node)yyVals[0+yyTop]));
                    } else {
                        yyVal = support.arg_append(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                    }
                }
  break;
case 299:
					// line 1436 "RubyParser.y"
  {
                    Node node = null;

                    if (((Node)yyVals[0+yyTop]) instanceof ArrayNode &&
                        (node = support.splat_array(((Node)yyVals[-3+yyTop]))) != null) {
                        yyVal = support.list_concat(node, ((Node)yyVals[0+yyTop]));
                    } else {
                        yyVal = ParserSupport.arg_concat(((Node)yyVals[-3+yyTop]), ((Node)yyVals[0+yyTop]));
                    }
                }
  break;
case 300:
					// line 1446 "RubyParser.y"
  {
                     yyVal = support.newSplatNode(((Node)yyVals[0+yyTop]));
                }
  break;
case 307:
					// line 1456 "RubyParser.y"
  { 
                     yyVal = ((ListNode)yyVals[0+yyTop]); /* FIXME: Why complaining without $$ = $1;*/
                }
  break;
case 308:
					// line 1459 "RubyParser.y"
  {
                     yyVal = ((ListNode)yyVals[0+yyTop]); /* FIXME: Why complaining without $$ = $1;*/
                }
  break;
case 311:
					// line 1464 "RubyParser.y"
  {
                     yyVal = support.new_fcall(((ByteList)yyVals[0+yyTop]));
                }
  break;
case 312:
					// line 1467 "RubyParser.y"
  {
                    yyVal = lexer.getCmdArgumentState().getStack();
                    lexer.getCmdArgumentState().reset();
                }
  break;
case 313:
					// line 1470 "RubyParser.y"
  {
                    lexer.getCmdArgumentState().reset(((Long)yyVals[-2+yyTop]).longValue());
                    yyVal = new BeginNode(((Integer)yyVals[-3+yyTop]), support.makeNullNil(((Node)yyVals[-1+yyTop])));
                }
  break;
case 314:
					// line 1474 "RubyParser.y"
  {
                    lexer.setState(EXPR_ENDARG);
                }
  break;
case 315:
					// line 1476 "RubyParser.y"
  {
                    yyVal = null; /*FIXME: Should be implicit nil?*/
                }
  break;
case 316:
					// line 1479 "RubyParser.y"
  {
                    yyVal = lexer.getCmdArgumentState().getStack();
                    lexer.getCmdArgumentState().reset();
                }
  break;
case 317:
					// line 1482 "RubyParser.y"
  {
                    lexer.setState(EXPR_ENDARG); 
                }
  break;
case 318:
					// line 1484 "RubyParser.y"
  {
                    lexer.getCmdArgumentState().reset(((Long)yyVals[-3+yyTop]).longValue());
                    yyVal = ((Node)yyVals[-2+yyTop]);
                }
  break;
case 319:
					// line 1488 "RubyParser.y"
  {
                    if (((Node)yyVals[-1+yyTop]) != null) {
                        /* compstmt position includes both parens around it*/
                        ((Node)yyVals[-1+yyTop]).setLine(((Integer)yyVals[-2+yyTop]));
                        yyVal = ((Node)yyVals[-1+yyTop]);
                    } else {
                        yyVal = new NilNode(((Integer)yyVals[-2+yyTop]));
                    }
                }
  break;
case 320:
					// line 1497 "RubyParser.y"
  {
                    yyVal = support.new_colon2(support.getPosition(((Node)yyVals[-2+yyTop])), ((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 321:
					// line 1500 "RubyParser.y"
  {
                    yyVal = support.new_colon3(lexer.tokline, ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 322:
					// line 1503 "RubyParser.y"
  {
                    Integer position = support.getPosition(((Node)yyVals[-1+yyTop]));
                    if (((Node)yyVals[-1+yyTop]) == null) {
                        yyVal = new ZArrayNode(position); /* zero length array */
                    } else {
                        yyVal = ((Node)yyVals[-1+yyTop]);
                    }
                }
  break;
case 323:
					// line 1511 "RubyParser.y"
  {
                    yyVal = ((HashNode)yyVals[-1+yyTop]);
                }
  break;
case 324:
					// line 1514 "RubyParser.y"
  {
                    yyVal = new ReturnNode(((Integer)yyVals[0+yyTop]), NilImplicitNode.NIL);
                }
  break;
case 325:
					// line 1517 "RubyParser.y"
  {
                    yyVal = support.new_yield(((Integer)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));
                }
  break;
case 326:
					// line 1520 "RubyParser.y"
  {
                    yyVal = new YieldNode(((Integer)yyVals[-2+yyTop]), null);
                }
  break;
case 327:
					// line 1523 "RubyParser.y"
  {
                    yyVal = new YieldNode(((Integer)yyVals[0+yyTop]), null);
                }
  break;
case 328:
					// line 1526 "RubyParser.y"
  {
                    yyVal = new DefinedNode(((Integer)yyVals[-4+yyTop]), ((Node)yyVals[-1+yyTop]));
                }
  break;
case 329:
					// line 1529 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(support.method_cond(((Node)yyVals[-1+yyTop])), lexer.BANG);
                }
  break;
case 330:
					// line 1532 "RubyParser.y"
  {
                    yyVal = support.getOperatorCallNode(support.method_cond(NilImplicitNode.NIL), lexer.BANG);
                }
  break;
case 331:
					// line 1535 "RubyParser.y"
  {
                    support.frobnicate_fcall_args(((FCallNode)yyVals[-1+yyTop]), null, ((IterNode)yyVals[0+yyTop]));
                    yyVal = ((FCallNode)yyVals[-1+yyTop]);                    
                }
  break;
case 333:
					// line 1540 "RubyParser.y"
  {
                    if (((Node)yyVals[-1+yyTop]) != null && 
                          ((BlockAcceptingNode)yyVals[-1+yyTop]).getIterNode() instanceof BlockPassNode) {
                          lexer.compile_error(PID.BLOCK_ARG_AND_BLOCK_GIVEN, "Both block arg and actual block given.");
                    }
                    yyVal = ((BlockAcceptingNode)yyVals[-1+yyTop]).setIterNode(((IterNode)yyVals[0+yyTop]));
                    ((Node)yyVal).setLine(((Node)yyVals[-1+yyTop]).getLine());
                }
  break;
case 334:
					// line 1548 "RubyParser.y"
  {
                    yyVal = ((LambdaNode)yyVals[0+yyTop]);
                }
  break;
case 335:
					// line 1551 "RubyParser.y"
  {
                    yyVal = support.new_if(((Integer)yyVals[-5+yyTop]), support.cond(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]));
                }
  break;
case 336:
					// line 1554 "RubyParser.y"
  {
                    yyVal = support.new_if(((Integer)yyVals[-5+yyTop]), support.cond(((Node)yyVals[-4+yyTop])), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[-2+yyTop]));
                }
  break;
case 337:
					// line 1557 "RubyParser.y"
  {
                    lexer.getConditionState().begin();
                }
  break;
case 338:
					// line 1559 "RubyParser.y"
  {
                    lexer.getConditionState().end();
                }
  break;
case 339:
					// line 1561 "RubyParser.y"
  {
                    Node body = support.makeNullNil(((Node)yyVals[-1+yyTop]));
                    yyVal = new WhileNode(((Integer)yyVals[-6+yyTop]), support.cond(((Node)yyVals[-4+yyTop])), body);
                }
  break;
case 340:
					// line 1565 "RubyParser.y"
  {
                  lexer.getConditionState().begin();
                }
  break;
case 341:
					// line 1567 "RubyParser.y"
  {
                  lexer.getConditionState().end();
                }
  break;
case 342:
					// line 1569 "RubyParser.y"
  {
                    Node body = support.makeNullNil(((Node)yyVals[-1+yyTop]));
                    yyVal = new UntilNode(((Integer)yyVals[-6+yyTop]), support.cond(((Node)yyVals[-4+yyTop])), body);
                }
  break;
case 343:
					// line 1573 "RubyParser.y"
  {
                    yyVal = support.newCaseNode(((Integer)yyVals[-4+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]));
                    support.fixpos(((Node)yyVal), ((Node)yyVals[-3+yyTop]));
                }
  break;
case 344:
					// line 1577 "RubyParser.y"
  {
                    yyVal = support.newCaseNode(((Integer)yyVals[-3+yyTop]), null, ((Node)yyVals[-1+yyTop]));
                }
  break;
case 345:
					// line 1580 "RubyParser.y"
  {
                    lexer.getConditionState().begin();
                }
  break;
case 346:
					// line 1582 "RubyParser.y"
  {
                    lexer.getConditionState().end();
                }
  break;
case 347:
					// line 1584 "RubyParser.y"
  {
                      /* ENEBO: Lots of optz in 1.9 parser here*/
                    yyVal = new ForNode(((Integer)yyVals[-8+yyTop]), ((Node)yyVals[-7+yyTop]), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[-4+yyTop]), support.getCurrentScope(), lexer.getRubySourceline());
                }
  break;
case 348:
					// line 1588 "RubyParser.y"
  {
                    if (support.isInDef()) {
                        support.yyerror("class definition in method body");
                    }
                    support.pushLocalScope();
                    yyVal = support.isInClass(); /* MRI reuses $1 but we use the value for position.*/
                    support.setIsInClass(true);
                }
  break;
case 349:
					// line 1595 "RubyParser.y"
  {
                    Node body = support.makeNullNil(((Node)yyVals[-1+yyTop]));

                    yyVal = new ClassNode(((Integer)yyVals[-5+yyTop]), ((Colon3Node)yyVals[-4+yyTop]), support.getCurrentScope(), body, ((Node)yyVals[-3+yyTop]), lexer.getRubySourceline());
                    support.popCurrentScope();
                    support.setIsInClass(((Boolean)yyVals[-2+yyTop]).booleanValue());
                }
  break;
case 350:
					// line 1602 "RubyParser.y"
  {
                    yyVal = new Integer((support.isInClass() ? 2 : 0) & (support.isInDef() ? 1 : 0));
                    support.setInDef(false);
                    support.setIsInClass(false);
                    support.pushLocalScope();
                }
  break;
case 351:
					// line 1607 "RubyParser.y"
  {
                    Node body = support.makeNullNil(((Node)yyVals[-1+yyTop]));

                    yyVal = new SClassNode(((Integer)yyVals[-6+yyTop]), ((Node)yyVals[-4+yyTop]), support.getCurrentScope(), body, lexer.getRubySourceline());
                    support.popCurrentScope();
                    support.setInDef(((((Integer)yyVals[-3+yyTop]).intValue()) & 1) != 0);
                    support.setIsInClass(((((Integer)yyVals[-3+yyTop]).intValue()) & 2) != 0);
                }
  break;
case 352:
					// line 1615 "RubyParser.y"
  {
                    if (support.isInDef()) { 
                        support.yyerror("module definition in method body");
                    }
                    yyVal = support.isInClass();
                    support.setIsInClass(true);
                    support.pushLocalScope();
                }
  break;
case 353:
					// line 1622 "RubyParser.y"
  {
                    Node body = support.makeNullNil(((Node)yyVals[-1+yyTop]));

                    yyVal = new ModuleNode(((Integer)yyVals[-4+yyTop]), ((Colon3Node)yyVals[-3+yyTop]), support.getCurrentScope(), body, lexer.getRubySourceline());
                    support.popCurrentScope();
                    support.setIsInClass(((Boolean)yyVals[-2+yyTop]).booleanValue());
                }
  break;
case 354:
					// line 1629 "RubyParser.y"
  {
                    support.isNextBreak = false;
                    support.pushLocalScope();
                    yyVal = lexer.getCurrentArg();
                    lexer.setCurrentArg(null);
                }
  break;
case 355:
					// line 1634 "RubyParser.y"
  {
                    yyVal = support.isInDef();
                    support.setInDef(true);
                }
  break;
case 356:
					// line 1637 "RubyParser.y"
  {
                    Node body = support.makeNullNil(((Node)yyVals[-1+yyTop]));

                    yyVal = new DefnNode(((Integer)yyVals[-6+yyTop]), support.symbolID(((ByteList)yyVals[-5+yyTop])), (ArgsNode) yyVals[-2+yyTop], support.getCurrentScope(), body, ((Integer)yyVals[0+yyTop]));
                    if (support.isNextBreak) ((DefnNode)yyVal).setContainsNextBreak();
                    support.isNextBreak = false;
                    support.popCurrentScope();
                    support.setInDef(((Boolean)yyVals[-3+yyTop]).booleanValue());
                    lexer.setCurrentArg(((ByteList)yyVals[-4+yyTop]));
                }
  break;
case 357:
					// line 1647 "RubyParser.y"
  {
                    support.isNextBreak = false;  
                    lexer.setState(EXPR_FNAME); 
                    yyVal = support.isInDef();
                    support.setInDef(true);
               }
  break;
case 358:
					// line 1652 "RubyParser.y"
  {
                    support.pushLocalScope();
                    lexer.setState(EXPR_ENDFN|EXPR_LABEL); /* force for args */
                    yyVal = lexer.getCurrentArg();
                    lexer.setCurrentArg(null);
                }
  break;
case 359:
					// line 1657 "RubyParser.y"
  {
                    Node body = ((Node)yyVals[-1+yyTop]);
                    if (body == null) body = NilImplicitNode.NIL;

                    yyVal = new DefsNode(((Integer)yyVals[-8+yyTop]), ((Node)yyVals[-7+yyTop]), support.symbolID(((ByteList)yyVals[-4+yyTop])), (ArgsNode) yyVals[-2+yyTop], support.getCurrentScope(), body, ((Integer)yyVals[0+yyTop]));
                    if (support.isNextBreak) ((DefsNode)yyVal).setContainsNextBreak();
                    support.isNextBreak = false;
                    support.popCurrentScope();
                    support.setInDef(((Boolean)yyVals[-5+yyTop]).booleanValue());
                    lexer.setCurrentArg(((ByteList)yyVals[-3+yyTop]));
                }
  break;
case 360:
					// line 1668 "RubyParser.y"
  {
                    support.isNextBreak = true;
                    yyVal = new BreakNode(((Integer)yyVals[0+yyTop]), NilImplicitNode.NIL);
                }
  break;
case 361:
					// line 1672 "RubyParser.y"
  {
                    support.isNextBreak = true;
                    yyVal = new NextNode(((Integer)yyVals[0+yyTop]), NilImplicitNode.NIL);
                }
  break;
case 362:
					// line 1676 "RubyParser.y"
  {
                    yyVal = new RedoNode(((Integer)yyVals[0+yyTop]));
                }
  break;
case 363:
					// line 1679 "RubyParser.y"
  {
                    yyVal = new RetryNode(((Integer)yyVals[0+yyTop]));
                }
  break;
case 364:
					// line 1683 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = ((Node)yyVals[0+yyTop]);
                    if (yyVal == null) yyVal = NilImplicitNode.NIL;
                }
  break;
case 365:
					// line 1689 "RubyParser.y"
  {
                    yyVal = ((Integer)yyVals[0+yyTop]);
                }
  break;
case 366:
					// line 1693 "RubyParser.y"
  {
                    yyVal = ((Integer)yyVals[0+yyTop]);
                }
  break;
case 367:
					// line 1697 "RubyParser.y"
  {
                    yyVal = ((Integer)yyVals[0+yyTop]);
                }
  break;
case 368:
					// line 1701 "RubyParser.y"
  {
                    if (support.isInClass() && !support.isInDef() && !support.getCurrentScope().isBlockScope()) {
                        lexer.compile_error(PID.TOP_LEVEL_RETURN, "Invalid return in class/module body");
                    }
                    yyVal = ((Integer)yyVals[0+yyTop]);
                }
  break;
case 375:
					// line 1716 "RubyParser.y"
  {
                    yyVal = support.new_if(((Integer)yyVals[-4+yyTop]), support.cond(((Node)yyVals[-3+yyTop])), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 377:
					// line 1721 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 379:
					// line 1727 "RubyParser.y"
  {
                }
  break;
case 380:
					// line 1730 "RubyParser.y"
  {
                     yyVal = support.assignableInCurr(((ByteList)yyVals[0+yyTop]), NilImplicitNode.NIL);
                }
  break;
case 381:
					// line 1733 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 382:
					// line 1738 "RubyParser.y"
  {
                    yyVal = support.newArrayNode(((Node)yyVals[0+yyTop]).getLine(), ((Node)yyVals[0+yyTop]));
                }
  break;
case 383:
					// line 1741 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));
                }
  break;
case 384:
					// line 1745 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[0+yyTop]).getLine(), ((ListNode)yyVals[0+yyTop]), null, null);
                }
  break;
case 385:
					// line 1748 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), support.assignableInCurr(((ByteList)yyVals[0+yyTop]), null), null);
                }
  break;
case 386:
					// line 1751 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-5+yyTop]).getLine(), ((ListNode)yyVals[-5+yyTop]), support.assignableInCurr(((ByteList)yyVals[-2+yyTop]), null), ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 387:
					// line 1754 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-2+yyTop]).getLine(), ((ListNode)yyVals[-2+yyTop]), new StarNode(lexer.getRubySourceline()), null);
                }
  break;
case 388:
					// line 1757 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(((ListNode)yyVals[-4+yyTop]).getLine(), ((ListNode)yyVals[-4+yyTop]), new StarNode(lexer.getRubySourceline()), ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 389:
					// line 1760 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(lexer.getRubySourceline(), null, support.assignableInCurr(((ByteList)yyVals[0+yyTop]), null), null);
                }
  break;
case 390:
					// line 1763 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(lexer.getRubySourceline(), null, support.assignableInCurr(((ByteList)yyVals[-2+yyTop]), null), ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 391:
					// line 1766 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(lexer.getRubySourceline(), null, new StarNode(lexer.getRubySourceline()), null);
                }
  break;
case 392:
					// line 1769 "RubyParser.y"
  {
                    yyVal = new MultipleAsgnNode(support.getPosition(((ListNode)yyVals[0+yyTop])), null, null, ((ListNode)yyVals[0+yyTop]));
                }
  break;
case 393:
					// line 1773 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 394:
					// line 1776 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(((ListNode)yyVals[-1+yyTop]).getLine(), ((ListNode)yyVals[-1+yyTop]), (ByteList) null, ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 395:
					// line 1779 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(lexer.getRubySourceline(), null, ((ByteList)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 396:
					// line 1782 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(((BlockArgNode)yyVals[0+yyTop]).getLine(), null, (ByteList) null, ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 397:
					// line 1786 "RubyParser.y"
  {
                    yyVal = ((ArgsTailHolder)yyVals[0+yyTop]);
                }
  break;
case 398:
					// line 1789 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(lexer.getRubySourceline(), null, (ByteList) null, null);
                }
  break;
case 399:
					// line 1794 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getLine(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 400:
					// line 1797 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-7+yyTop]).getLine(), ((ListNode)yyVals[-7+yyTop]), ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 401:
					// line 1800 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 402:
					// line 1803 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getLine(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 403:
					// line 1806 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 404:
					// line 1809 "RubyParser.y"
  {
                    RestArgNode rest = new UnnamedRestArgNode(((ListNode)yyVals[-1+yyTop]).getLine(), null, support.getCurrentScope().addVariable("*"));
                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getLine(), ((ListNode)yyVals[-1+yyTop]), null, rest, null, (ArgsTailHolder) null);
                }
  break;
case 405:
					// line 1813 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getLine(), ((ListNode)yyVals[-5+yyTop]), null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 406:
					// line 1816 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getLine(), ((ListNode)yyVals[-1+yyTop]), null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 407:
					// line 1819 "RubyParser.y"
  {
                    yyVal = support.new_args(support.getPosition(((ListNode)yyVals[-3+yyTop])), null, ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 408:
					// line 1822 "RubyParser.y"
  {
                    yyVal = support.new_args(support.getPosition(((ListNode)yyVals[-5+yyTop])), null, ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 409:
					// line 1825 "RubyParser.y"
  {
                    yyVal = support.new_args(support.getPosition(((ListNode)yyVals[-1+yyTop])), null, ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 410:
					// line 1828 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getLine(), null, ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 411:
					// line 1831 "RubyParser.y"
  {
                    yyVal = support.new_args(((RestArgNode)yyVals[-1+yyTop]).getLine(), null, null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 412:
					// line 1834 "RubyParser.y"
  {
                    yyVal = support.new_args(((RestArgNode)yyVals[-3+yyTop]).getLine(), null, null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 413:
					// line 1837 "RubyParser.y"
  {
                    yyVal = support.new_args(((ArgsTailHolder)yyVals[0+yyTop]).getLine(), null, null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 414:
					// line 1841 "RubyParser.y"
  {
    /* was $$ = null;*/
                    yyVal = support.new_args(lexer.getRubySourceline(), null, null, null, null, (ArgsTailHolder) null);
                }
  break;
case 415:
					// line 1845 "RubyParser.y"
  {
                    lexer.commandStart = true;
                    yyVal = ((ArgsNode)yyVals[0+yyTop]);
                }
  break;
case 416:
					// line 1850 "RubyParser.y"
  {
                    lexer.setCurrentArg(null);
                    yyVal = support.new_args(lexer.getRubySourceline(), null, null, null, null, (ArgsTailHolder) null);
                }
  break;
case 417:
					// line 1854 "RubyParser.y"
  {
                    yyVal = support.new_args(lexer.getRubySourceline(), null, null, null, null, (ArgsTailHolder) null);
                }
  break;
case 418:
					// line 1857 "RubyParser.y"
  {
                    lexer.setCurrentArg(null);
                    yyVal = ((ArgsNode)yyVals[-2+yyTop]);
                }
  break;
case 419:
					// line 1863 "RubyParser.y"
  {
                    yyVal = null;
                }
  break;
case 420:
					// line 1866 "RubyParser.y"
  {
                    yyVal = null;
                }
  break;
case 421:
					// line 1871 "RubyParser.y"
  {
                    yyVal = null;
                }
  break;
case 422:
					// line 1874 "RubyParser.y"
  {
                    yyVal = null;
                }
  break;
case 423:
					// line 1878 "RubyParser.y"
  {
                    support.new_bv(((ByteList)yyVals[0+yyTop]));
                }
  break;
case 424:
					// line 1881 "RubyParser.y"
  {
                    yyVal = null;
                }
  break;
case 425:
					// line 1885 "RubyParser.y"
  {
                    support.pushBlockScope();
                    yyVal = lexer.getLeftParenBegin();
                    lexer.setLeftParenBegin(lexer.incrementParenNest());
                }
  break;
case 426:
					// line 1889 "RubyParser.y"
  {
                    yyVal = Long.valueOf(lexer.getCmdArgumentState().getStack());
                    lexer.getCmdArgumentState().reset();
                }
  break;
case 427:
					// line 1892 "RubyParser.y"
  {
                    lexer.getCmdArgumentState().reset(((Long)yyVals[-1+yyTop]).longValue());
                    lexer.getCmdArgumentState().restart();
                    yyVal = new LambdaNode(((ArgsNode)yyVals[-2+yyTop]).getLine(), ((ArgsNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]), support.getCurrentScope(), lexer.getRubySourceline());
                    lexer.setLeftParenBegin(((Integer)yyVals[-3+yyTop]));
                    support.popCurrentScope();
                }
  break;
case 428:
					// line 1900 "RubyParser.y"
  {
                    yyVal = ((ArgsNode)yyVals[-2+yyTop]);
                }
  break;
case 429:
					// line 1903 "RubyParser.y"
  {
                    yyVal = ((ArgsNode)yyVals[0+yyTop]);
                }
  break;
case 430:
					// line 1907 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 431:
					// line 1910 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 432:
					// line 1914 "RubyParser.y"
  {
                    yyVal = ((IterNode)yyVals[-1+yyTop]);
                }
  break;
case 433:
					// line 1922 "RubyParser.y"
  {
                    /* Workaround for JRUBY-2326 (MRI does not enter this production for some reason)*/
                    if (((Node)yyVals[-1+yyTop]) instanceof YieldNode) {
                        lexer.compile_error(PID.BLOCK_GIVEN_TO_YIELD, "block given to yield");
                    }
                    if (((Node)yyVals[-1+yyTop]) instanceof BlockAcceptingNode && ((BlockAcceptingNode)yyVals[-1+yyTop]).getIterNode() instanceof BlockPassNode) {
                        lexer.compile_error(PID.BLOCK_ARG_AND_BLOCK_GIVEN, "Both block arg and actual block given.");
                    }
                    if (((Node)yyVals[-1+yyTop]) instanceof NonLocalControlFlowNode) {
                        ((BlockAcceptingNode) ((NonLocalControlFlowNode)yyVals[-1+yyTop]).getValueNode()).setIterNode(((IterNode)yyVals[0+yyTop]));
                    } else {
                        ((BlockAcceptingNode)yyVals[-1+yyTop]).setIterNode(((IterNode)yyVals[0+yyTop]));
                    }
                    yyVal = ((Node)yyVals[-1+yyTop]);
                    ((Node)yyVal).setLine(((Node)yyVals[-1+yyTop]).getLine());
                }
  break;
case 434:
					// line 1938 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 435:
					// line 1941 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));
                }
  break;
case 436:
					// line 1944 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-4+yyTop]), ((ByteList)yyVals[-3+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((Node)yyVals[-1+yyTop]), ((IterNode)yyVals[0+yyTop]));
                }
  break;
case 437:
					// line 1949 "RubyParser.y"
  {
                    support.frobnicate_fcall_args(((FCallNode)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                    yyVal = ((FCallNode)yyVals[-1+yyTop]);
                }
  break;
case 438:
					// line 1953 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((ByteList)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 439:
					// line 1956 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-3+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 440:
					// line 1959 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[0+yyTop]), null, null);
                }
  break;
case 441:
					// line 1962 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-2+yyTop]), ((ByteList)yyVals[-1+yyTop]), LexingCommon.CALL, ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 442:
					// line 1965 "RubyParser.y"
  {
                    yyVal = support.new_call(((Node)yyVals[-2+yyTop]), LexingCommon.CALL, ((Node)yyVals[0+yyTop]), null);
                }
  break;
case 443:
					// line 1968 "RubyParser.y"
  {
                    yyVal = support.new_super(((Integer)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 444:
					// line 1971 "RubyParser.y"
  {
                    yyVal = new ZSuperNode(((Integer)yyVals[0+yyTop]));
                }
  break;
case 445:
					// line 1974 "RubyParser.y"
  {
                    if (((Node)yyVals[-3+yyTop]) instanceof SelfNode) {
                        yyVal = support.new_fcall(LexingCommon.LBRACKET_RBRACKET);
                        support.frobnicate_fcall_args(((FCallNode)yyVal), ((Node)yyVals[-1+yyTop]), null);
                    } else {
                        yyVal = support.new_call(((Node)yyVals[-3+yyTop]), lexer.LBRACKET_RBRACKET, ((Node)yyVals[-1+yyTop]), null);
                    }
                }
  break;
case 446:
					// line 1983 "RubyParser.y"
  {
                    yyVal = ((IterNode)yyVals[-1+yyTop]);
                }
  break;
case 447:
					// line 1986 "RubyParser.y"
  {
                    yyVal = ((IterNode)yyVals[-1+yyTop]);
                }
  break;
case 448:
					// line 1990 "RubyParser.y"
  {
                    yyVal = lexer.getRubySourceline();
                }
  break;
case 449:
					// line 1992 "RubyParser.y"
  {
                    support.pushBlockScope();
                    yyVal = Long.valueOf(lexer.getCmdArgumentState().getStack()) >> 1;
                    lexer.getCmdArgumentState().reset();
                }
  break;
case 450:
					// line 1996 "RubyParser.y"
  {
                    yyVal = new IterNode(((Integer)yyVals[-3+yyTop]), ((ArgsNode)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), support.getCurrentScope(), lexer.getRubySourceline());
                    support.popCurrentScope();
                    lexer.getCmdArgumentState().reset(((Long)yyVals[-2+yyTop]).longValue());
                }
  break;
case 451:
					// line 2002 "RubyParser.y"
  {
                    yyVal = lexer.getRubySourceline();
                }
  break;
case 452:
					// line 2004 "RubyParser.y"
  {
                    support.pushBlockScope();
                    yyVal = Long.valueOf(lexer.getCmdArgumentState().getStack());
                    lexer.getCmdArgumentState().reset();
                }
  break;
case 453:
					// line 2008 "RubyParser.y"
  {
                    yyVal = new IterNode(((Integer)yyVals[-3+yyTop]), ((ArgsNode)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]), support.getCurrentScope(), lexer.getRubySourceline());
                    support.popCurrentScope();
                    lexer.getCmdArgumentState().reset(((Long)yyVals[-2+yyTop]).longValue());
                }
  break;
case 454:
					// line 2014 "RubyParser.y"
  {
                    yyVal = support.newWhenNode(((Integer)yyVals[-4+yyTop]), ((Node)yyVals[-3+yyTop]), ((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 457:
					// line 2020 "RubyParser.y"
  {
                    Node node;
                    if (((Node)yyVals[-3+yyTop]) != null) {
                        node = support.appendToBlock(node_assign(((Node)yyVals[-3+yyTop]), new GlobalVarNode(((Integer)yyVals[-5+yyTop]), support.symbolID(lexer.DOLLAR_BANG))), ((Node)yyVals[-1+yyTop]));
                        if (((Node)yyVals[-1+yyTop]) != null) {
                            node.setLine(((Integer)yyVals[-5+yyTop]));
                        }
                    } else {
                        node = ((Node)yyVals[-1+yyTop]);
                    }
                    Node body = support.makeNullNil(node);
                    yyVal = new RescueBodyNode(((Integer)yyVals[-5+yyTop]), ((Node)yyVals[-4+yyTop]), body, ((RescueBodyNode)yyVals[0+yyTop]));
                }
  break;
case 458:
					// line 2033 "RubyParser.y"
  {
                    yyVal = null; 
                }
  break;
case 459:
					// line 2037 "RubyParser.y"
  {
                    yyVal = support.newArrayNode(((Node)yyVals[0+yyTop]).getLine(), ((Node)yyVals[0+yyTop]));
                }
  break;
case 460:
					// line 2040 "RubyParser.y"
  {
                    yyVal = support.splat_array(((Node)yyVals[0+yyTop]));
                    if (yyVal == null) yyVal = ((Node)yyVals[0+yyTop]); /* ArgsCat or ArgsPush*/
                }
  break;
case 462:
					// line 2046 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 464:
					// line 2051 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 466:
					// line 2056 "RubyParser.y"
  {
                    yyVal = ((NumericNode)yyVals[0+yyTop]);
                }
  break;
case 467:
					// line 2059 "RubyParser.y"
  {
                    yyVal = support.asSymbol(lexer.getRubySourceline(), ((ByteList)yyVals[0+yyTop]));
                }
  break;
case 469:
					// line 2064 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]) instanceof EvStrNode ? new DStrNode(((Node)yyVals[0+yyTop]).getLine(), lexer.getEncoding()).add(((Node)yyVals[0+yyTop])) : ((Node)yyVals[0+yyTop]);
                    /*
                    NODE *node = $1;
                    if (!node) {
                        node = NEW_STR(STR_NEW0());
                    } else {
                        node = evstr2dstr(node);
                    }
                    $$ = node;
                    */
                }
  break;
case 470:
					// line 2078 "RubyParser.y"
  {
                    yyVal = ((StrNode)yyVals[0+yyTop]);
                }
  break;
case 471:
					// line 2081 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 472:
					// line 2084 "RubyParser.y"
  {
                    yyVal = support.literal_concat(((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 473:
					// line 2088 "RubyParser.y"
  {
                    lexer.heredoc_dedent(((Node)yyVals[-1+yyTop]));
		    lexer.setHeredocIndent(0);
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 474:
					// line 2094 "RubyParser.y"
  {
                    int line = support.getPosition(((Node)yyVals[-1+yyTop]));

                    lexer.heredoc_dedent(((Node)yyVals[-1+yyTop]));
		    lexer.setHeredocIndent(0);

                    if (((Node)yyVals[-1+yyTop]) == null) {
                        yyVal = new XStrNode(line, null, StringSupport.CR_7BIT);
                    } else if (((Node)yyVals[-1+yyTop]) instanceof StrNode) {
                        yyVal = new XStrNode(line, (ByteList) ((StrNode)yyVals[-1+yyTop]).getValue().clone(), ((StrNode)yyVals[-1+yyTop]).getCodeRange());
                    } else if (((Node)yyVals[-1+yyTop]) instanceof DStrNode) {
                        yyVal = new DXStrNode(line, ((DStrNode)yyVals[-1+yyTop]));

                        ((Node)yyVal).setLine(line);
                    } else {
                        yyVal = new DXStrNode(line).add(((Node)yyVals[-1+yyTop]));
                    }
                }
  break;
case 475:
					// line 2113 "RubyParser.y"
  {
                    yyVal = support.newRegexpNode(support.getPosition(((Node)yyVals[-1+yyTop])), ((Node)yyVals[-1+yyTop]), (RegexpNode) ((RegexpNode)yyVals[0+yyTop]));
                }
  break;
case 476:
					// line 2117 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-1+yyTop]);
                }
  break;
case 477:
					// line 2121 "RubyParser.y"
  {
                     yyVal = new ArrayNode(lexer.getRubySourceline());
                }
  break;
case 478:
					// line 2124 "RubyParser.y"
  {
                     yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]) instanceof EvStrNode ? new DStrNode(((ListNode)yyVals[-2+yyTop]).getLine(), lexer.getEncoding()).add(((Node)yyVals[-1+yyTop])) : ((Node)yyVals[-1+yyTop]));
                }
  break;
case 479:
					// line 2128 "RubyParser.y"
  {
                     yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 480:
					// line 2131 "RubyParser.y"
  {
                     yyVal = support.literal_concat(((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 481:
					// line 2135 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-1+yyTop]);
                }
  break;
case 482:
					// line 2139 "RubyParser.y"
  {
                    yyVal = new ArrayNode(lexer.getRubySourceline());
                }
  break;
case 483:
					// line 2142 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]) instanceof EvStrNode ? new DSymbolNode(((ListNode)yyVals[-2+yyTop]).getLine()).add(((Node)yyVals[-1+yyTop])) : support.asSymbol(((ListNode)yyVals[-2+yyTop]).getLine(), ((Node)yyVals[-1+yyTop])));
                }
  break;
case 484:
					// line 2146 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-1+yyTop]);
                }
  break;
case 485:
					// line 2150 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-1+yyTop]);
                }
  break;
case 486:
					// line 2155 "RubyParser.y"
  {
                    yyVal = new ArrayNode(lexer.getRubySourceline());
                }
  break;
case 487:
					// line 2158 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[-1+yyTop]));
                }
  break;
case 488:
					// line 2162 "RubyParser.y"
  {
                    yyVal = new ArrayNode(lexer.getRubySourceline());
                }
  break;
case 489:
					// line 2165 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(support.asSymbol(((ListNode)yyVals[-2+yyTop]).getLine(), ((Node)yyVals[-1+yyTop])));
                }
  break;
case 490:
					// line 2169 "RubyParser.y"
  {
                    ByteList aChar = ByteList.create("");
                    aChar.setEncoding(lexer.getEncoding());
                    yyVal = lexer.createStr(aChar, 0);
                }
  break;
case 491:
					// line 2174 "RubyParser.y"
  {
                    yyVal = support.literal_concat(((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 492:
					// line 2178 "RubyParser.y"
  {
                    ByteList aChar = ByteList.create("");
                    aChar.setEncoding(lexer.getEncoding());
                    yyVal = lexer.createStr(aChar, 0);
                }
  break;
case 493:
					// line 2183 "RubyParser.y"
  {
                    yyVal = support.literal_concat(((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 494:
					// line 2187 "RubyParser.y"
  {
                    yyVal = null;
                }
  break;
case 495:
					// line 2190 "RubyParser.y"
  {
    /* FIXME: mri is different here.*/
                    yyVal = support.literal_concat(((Node)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 496:
					// line 2195 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 497:
					// line 2198 "RubyParser.y"
  {
                    yyVal = lexer.getStrTerm();
                    lexer.setStrTerm(null);
                    lexer.setState(EXPR_BEG);
                }
  break;
case 498:
					// line 2202 "RubyParser.y"
  {
                    lexer.setStrTerm(((StrTerm)yyVals[-1+yyTop]));
                    yyVal = new EvStrNode(support.getPosition(((Node)yyVals[0+yyTop])), ((Node)yyVals[0+yyTop]));
                }
  break;
case 499:
					// line 2206 "RubyParser.y"
  {
                   yyVal = lexer.getStrTerm();
                   lexer.setStrTerm(null);
                   lexer.getConditionState().stop();
                }
  break;
case 500:
					// line 2210 "RubyParser.y"
  {
                   yyVal = lexer.getCmdArgumentState().getStack();
                   lexer.getCmdArgumentState().reset();
                }
  break;
case 501:
					// line 2213 "RubyParser.y"
  {
                   yyVal = lexer.getState();
                   lexer.setState(EXPR_BEG);
                }
  break;
case 502:
					// line 2216 "RubyParser.y"
  {
                   yyVal = lexer.getBraceNest();
                   lexer.setBraceNest(0);
                }
  break;
case 503:
					// line 2219 "RubyParser.y"
  {
                   yyVal = lexer.getHeredocIndent();
                   lexer.setHeredocIndent(0);
                }
  break;
case 504:
					// line 2222 "RubyParser.y"
  {
                   lexer.getConditionState().restart();
                   lexer.setStrTerm(((StrTerm)yyVals[-6+yyTop]));
                   lexer.getCmdArgumentState().reset(((Long)yyVals[-5+yyTop]).longValue());
                   lexer.setState(((Integer)yyVals[-4+yyTop]));
                   lexer.setBraceNest(((Integer)yyVals[-3+yyTop]));
                   lexer.setHeredocIndent(((Integer)yyVals[-2+yyTop]));
                   lexer.setHeredocLineIndent(-1);

                   if (((Node)yyVals[-1+yyTop]) != null) ((Node)yyVals[-1+yyTop]).unsetNewline();
                   yyVal = support.newEvStrNode(support.getPosition(((Node)yyVals[-1+yyTop])), ((Node)yyVals[-1+yyTop]));
                }
  break;
case 505:
					// line 2235 "RubyParser.y"
  {
                     yyVal = new GlobalVarNode(lexer.getRubySourceline(), support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 506:
					// line 2238 "RubyParser.y"
  {
                     yyVal = new InstVarNode(lexer.getRubySourceline(), support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 507:
					// line 2241 "RubyParser.y"
  {
                     yyVal = new ClassVarNode(lexer.getRubySourceline(), support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 509:
					// line 2247 "RubyParser.y"
  {
                     lexer.setState(EXPR_END|EXPR_ENDARG);
                     yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 511:
					// line 2254 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 512:
					// line 2257 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 513:
					// line 2260 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 514:
					// line 2264 "RubyParser.y"
  {
                     lexer.setState(EXPR_END|EXPR_ENDARG);

                     /* DStrNode: :"some text #{some expression}"*/
                     /* StrNode: :"some text"*/
                     /* EvStrNode :"#{some expression}"*/
                     /* Ruby 1.9 allows empty strings as symbols*/
                     if (((Node)yyVals[-1+yyTop]) == null) {
                         yyVal = support.asSymbol(lexer.getRubySourceline(), new ByteList(new byte[] {}));
                     } else if (((Node)yyVals[-1+yyTop]) instanceof DStrNode) {
                         yyVal = new DSymbolNode(((Node)yyVals[-1+yyTop]).getLine(), ((DStrNode)yyVals[-1+yyTop]));
                     } else if (((Node)yyVals[-1+yyTop]) instanceof StrNode) {
                         yyVal = support.asSymbol(((Node)yyVals[-1+yyTop]).getLine(), ((Node)yyVals[-1+yyTop]));
                     } else {
                         yyVal = new DSymbolNode(((Node)yyVals[-1+yyTop]).getLine());
                         ((DSymbolNode)yyVal).add(((Node)yyVals[-1+yyTop]));
                     }
                }
  break;
case 515:
					// line 2283 "RubyParser.y"
  {
                    yyVal = ((NumericNode)yyVals[0+yyTop]);  
                }
  break;
case 516:
					// line 2286 "RubyParser.y"
  {
                     yyVal = support.negateNumeric(((NumericNode)yyVals[0+yyTop]));
                }
  break;
case 517:
					// line 2290 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 518:
					// line 2293 "RubyParser.y"
  {
                     yyVal = ((FloatNode)yyVals[0+yyTop]);
                }
  break;
case 519:
					// line 2296 "RubyParser.y"
  {
                     yyVal = ((RationalNode)yyVals[0+yyTop]);
                }
  break;
case 520:
					// line 2299 "RubyParser.y"
  {
                     yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 521:
					// line 2304 "RubyParser.y"
  {
                    yyVal = support.declareIdentifier(((ByteList)yyVals[0+yyTop]));
                }
  break;
case 522:
					// line 2307 "RubyParser.y"
  {
                    yyVal = new InstVarNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 523:
					// line 2310 "RubyParser.y"
  {
                    yyVal = new GlobalVarNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 524:
					// line 2313 "RubyParser.y"
  {
                    yyVal = new ConstNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 525:
					// line 2316 "RubyParser.y"
  {
                    yyVal = new ClassVarNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])));
                }
  break;
case 526:
					// line 2319 "RubyParser.y"
  { 
                    yyVal = new NilNode(lexer.tokline);
                }
  break;
case 527:
					// line 2322 "RubyParser.y"
  {
                    yyVal = new SelfNode(lexer.tokline);
                }
  break;
case 528:
					// line 2325 "RubyParser.y"
  { 
                    yyVal = new TrueNode(lexer.tokline);
                }
  break;
case 529:
					// line 2328 "RubyParser.y"
  {
                    yyVal = new FalseNode(lexer.tokline);
                }
  break;
case 530:
					// line 2331 "RubyParser.y"
  {
                    yyVal = new FileNode(lexer.tokline, new ByteList(lexer.getFile().getBytes(),
                    support.getConfiguration().getRuntime().getEncodingService().getLocaleEncoding()));
                }
  break;
case 531:
					// line 2335 "RubyParser.y"
  {
                    yyVal = new FixnumNode(lexer.tokline, lexer.tokline+1);
                }
  break;
case 532:
					// line 2338 "RubyParser.y"
  {
                    yyVal = new EncodingNode(lexer.tokline, lexer.getEncoding());
                }
  break;
case 533:
					// line 2343 "RubyParser.y"
  {
                    yyVal = support.assignableLabelOrIdentifier(((ByteList)yyVals[0+yyTop]), null);
                }
  break;
case 534:
					// line 2346 "RubyParser.y"
  {
                    yyVal = new InstAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 535:
					// line 2349 "RubyParser.y"
  {
                    yyVal = new GlobalAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 536:
					// line 2352 "RubyParser.y"
  {
                    if (support.isInDef()) support.compile_error("dynamic constant assignment");

                    yyVal = new ConstDeclNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), null, NilImplicitNode.NIL);
                }
  break;
case 537:
					// line 2357 "RubyParser.y"
  {
                    yyVal = new ClassVarAsgnNode(lexer.tokline, support.symbolID(((ByteList)yyVals[0+yyTop])), NilImplicitNode.NIL);
                }
  break;
case 538:
					// line 2360 "RubyParser.y"
  {
                    support.compile_error("Can't assign to nil");
                    yyVal = null;
                }
  break;
case 539:
					// line 2364 "RubyParser.y"
  {
                    support.compile_error("Can't change the value of self");
                    yyVal = null;
                }
  break;
case 540:
					// line 2368 "RubyParser.y"
  {
                    support.compile_error("Can't assign to true");
                    yyVal = null;
                }
  break;
case 541:
					// line 2372 "RubyParser.y"
  {
                    support.compile_error("Can't assign to false");
                    yyVal = null;
                }
  break;
case 542:
					// line 2376 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __FILE__");
                    yyVal = null;
                }
  break;
case 543:
					// line 2380 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __LINE__");
                    yyVal = null;
                }
  break;
case 544:
					// line 2384 "RubyParser.y"
  {
                    support.compile_error("Can't assign to __ENCODING__");
                    yyVal = null;
                }
  break;
case 545:
					// line 2390 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 546:
					// line 2393 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 547:
					// line 2397 "RubyParser.y"
  {
                   lexer.setState(EXPR_BEG);
                   lexer.commandStart = true;
                }
  break;
case 548:
					// line 2400 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 549:
					// line 2403 "RubyParser.y"
  {
                   yyVal = null;
                }
  break;
case 550:
					// line 2408 "RubyParser.y"
  {
                    yyVal = ((ArgsNode)yyVals[-1+yyTop]);
                    lexer.setState(EXPR_BEG);
                    lexer.commandStart = true;
                }
  break;
case 551:
					// line 2413 "RubyParser.y"
  {
                   yyVal = lexer.inKwarg;
                   lexer.inKwarg = true;
                   lexer.setState(lexer.getState() | EXPR_LABEL);
                }
  break;
case 552:
					// line 2417 "RubyParser.y"
  {
                   lexer.inKwarg = ((Boolean)yyVals[-2+yyTop]);
                    yyVal = ((ArgsNode)yyVals[-1+yyTop]);
                    lexer.setState(EXPR_BEG);
                    lexer.commandStart = true;
                }
  break;
case 553:
					// line 2425 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), ((ByteList)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 554:
					// line 2428 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(((ListNode)yyVals[-1+yyTop]).getLine(), ((ListNode)yyVals[-1+yyTop]), (ByteList) null, ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 555:
					// line 2431 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(lexer.getRubySourceline(), null, ((ByteList)yyVals[-1+yyTop]), ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 556:
					// line 2434 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(((BlockArgNode)yyVals[0+yyTop]).getLine(), null, (ByteList) null, ((BlockArgNode)yyVals[0+yyTop]));
                }
  break;
case 557:
					// line 2438 "RubyParser.y"
  {
                    yyVal = ((ArgsTailHolder)yyVals[0+yyTop]);
                }
  break;
case 558:
					// line 2441 "RubyParser.y"
  {
                    yyVal = support.new_args_tail(lexer.getRubySourceline(), null, (ByteList) null, null);
                }
  break;
case 559:
					// line 2446 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getLine(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 560:
					// line 2449 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-7+yyTop]).getLine(), ((ListNode)yyVals[-7+yyTop]), ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 561:
					// line 2452 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 562:
					// line 2455 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getLine(), ((ListNode)yyVals[-5+yyTop]), ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 563:
					// line 2458 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getLine(), ((ListNode)yyVals[-3+yyTop]), null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 564:
					// line 2461 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getLine(), ((ListNode)yyVals[-5+yyTop]), null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 565:
					// line 2464 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getLine(), ((ListNode)yyVals[-1+yyTop]), null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 566:
					// line 2467 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getLine(), null, ((ListNode)yyVals[-3+yyTop]), ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 567:
					// line 2470 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-5+yyTop]).getLine(), null, ((ListNode)yyVals[-5+yyTop]), ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 568:
					// line 2473 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-1+yyTop]).getLine(), null, ((ListNode)yyVals[-1+yyTop]), null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 569:
					// line 2476 "RubyParser.y"
  {
                    yyVal = support.new_args(((ListNode)yyVals[-3+yyTop]).getLine(), null, ((ListNode)yyVals[-3+yyTop]), null, ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 570:
					// line 2479 "RubyParser.y"
  {
                    yyVal = support.new_args(((RestArgNode)yyVals[-1+yyTop]).getLine(), null, null, ((RestArgNode)yyVals[-1+yyTop]), null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 571:
					// line 2482 "RubyParser.y"
  {
                    yyVal = support.new_args(((RestArgNode)yyVals[-3+yyTop]).getLine(), null, null, ((RestArgNode)yyVals[-3+yyTop]), ((ListNode)yyVals[-1+yyTop]), ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 572:
					// line 2485 "RubyParser.y"
  {
                    yyVal = support.new_args(((ArgsTailHolder)yyVals[0+yyTop]).getLine(), null, null, null, null, ((ArgsTailHolder)yyVals[0+yyTop]));
                }
  break;
case 573:
					// line 2488 "RubyParser.y"
  {
                    yyVal = support.new_args(lexer.getRubySourceline(), null, null, null, null, (ArgsTailHolder) null);
                }
  break;
case 574:
					// line 2492 "RubyParser.y"
  {
                    support.yyerror("formal argument cannot be a constant");
                }
  break;
case 575:
					// line 2495 "RubyParser.y"
  {
                    support.yyerror("formal argument cannot be an instance variable");
                }
  break;
case 576:
					// line 2498 "RubyParser.y"
  {
                    support.yyerror("formal argument cannot be a global variable");
                }
  break;
case 577:
					// line 2501 "RubyParser.y"
  {
                    support.yyerror("formal argument cannot be a class variable");
                }
  break;
case 578:
					// line 2506 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]); /* Not really reached*/
                }
  break;
case 579:
					// line 2509 "RubyParser.y"
  {
                    yyVal = support.formal_argument(((ByteList)yyVals[0+yyTop]));
                }
  break;
case 580:
					// line 2513 "RubyParser.y"
  {
                    lexer.setCurrentArg(((ByteList)yyVals[0+yyTop]));
                    yyVal = support.arg_var(((ByteList)yyVals[0+yyTop]));
                }
  break;
case 581:
					// line 2518 "RubyParser.y"
  {
                    lexer.setCurrentArg(null);
                    yyVal = ((ArgumentNode)yyVals[0+yyTop]);
                }
  break;
case 582:
					// line 2522 "RubyParser.y"
  {
                    yyVal = ((Node)yyVals[-1+yyTop]);
                    /*            {
            ID tid = internal_id();
            arg_var(tid);
            if (dyna_in_block()) {
                $2->nd_value = NEW_DVAR(tid);
            }
            else {
                $2->nd_value = NEW_LVAR(tid);
            }
            $$ = NEW_ARGS_AUX(tid, 1);
            $$->nd_next = $2;*/
                }
  break;
case 583:
					// line 2538 "RubyParser.y"
  {
                    yyVal = new ArrayNode(lexer.getRubySourceline(), ((Node)yyVals[0+yyTop]));
                }
  break;
case 584:
					// line 2541 "RubyParser.y"
  {
                    ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));
                    yyVal = ((ListNode)yyVals[-2+yyTop]);
                }
  break;
case 585:
					// line 2546 "RubyParser.y"
  {
                    support.arg_var(support.formal_argument(((ByteList)yyVals[0+yyTop])));
                    lexer.setCurrentArg(((ByteList)yyVals[0+yyTop]));
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 586:
					// line 2552 "RubyParser.y"
  {
                    lexer.setCurrentArg(null);
                    yyVal = new KeywordArgNode(((Node)yyVals[0+yyTop]).getLine(), support.assignableKeyword(((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop])));
                }
  break;
case 587:
					// line 2556 "RubyParser.y"
  {
                    lexer.setCurrentArg(null);
                    yyVal = new KeywordArgNode(lexer.getRubySourceline(), support.assignableKeyword(((ByteList)yyVals[0+yyTop]), new RequiredKeywordArgumentValueNode()));
                }
  break;
case 588:
					// line 2561 "RubyParser.y"
  {
                    yyVal = new KeywordArgNode(support.getPosition(((Node)yyVals[0+yyTop])), support.assignableKeyword(((ByteList)yyVals[-1+yyTop]), ((Node)yyVals[0+yyTop])));
                }
  break;
case 589:
					// line 2564 "RubyParser.y"
  {
                    yyVal = new KeywordArgNode(lexer.getRubySourceline(), support.assignableKeyword(((ByteList)yyVals[0+yyTop]), new RequiredKeywordArgumentValueNode()));
                }
  break;
case 590:
					// line 2569 "RubyParser.y"
  {
                    yyVal = new ArrayNode(((Node)yyVals[0+yyTop]).getLine(), ((Node)yyVals[0+yyTop]));
                }
  break;
case 591:
					// line 2572 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));
                }
  break;
case 592:
					// line 2576 "RubyParser.y"
  {
                    yyVal = new ArrayNode(((Node)yyVals[0+yyTop]).getLine(), ((Node)yyVals[0+yyTop]));
                }
  break;
case 593:
					// line 2579 "RubyParser.y"
  {
                    yyVal = ((ListNode)yyVals[-2+yyTop]).add(((Node)yyVals[0+yyTop]));
                }
  break;
case 594:
					// line 2583 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 595:
					// line 2586 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 596:
					// line 2590 "RubyParser.y"
  {
                    support.shadowing_lvar(((ByteList)yyVals[0+yyTop]));
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 597:
					// line 2594 "RubyParser.y"
  {
                    yyVal = support.INTERNAL_ID;
                }
  break;
case 598:
					// line 2598 "RubyParser.y"
  {
                    lexer.setCurrentArg(null);
                    yyVal = new OptArgNode(support.getPosition(((Node)yyVals[0+yyTop])), support.assignableLabelOrIdentifier(((ArgumentNode)yyVals[-2+yyTop]).getName().getBytes(), ((Node)yyVals[0+yyTop])));
                }
  break;
case 599:
					// line 2603 "RubyParser.y"
  {
                    lexer.setCurrentArg(null);
                    yyVal = new OptArgNode(support.getPosition(((Node)yyVals[0+yyTop])), support.assignableLabelOrIdentifier(((ArgumentNode)yyVals[-2+yyTop]).getName().getBytes(), ((Node)yyVals[0+yyTop])));
                }
  break;
case 600:
					// line 2608 "RubyParser.y"
  {
                    yyVal = new BlockNode(((Node)yyVals[0+yyTop]).getLine()).add(((Node)yyVals[0+yyTop]));
                }
  break;
case 601:
					// line 2611 "RubyParser.y"
  {
                    yyVal = support.appendToBlock(((ListNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 602:
					// line 2615 "RubyParser.y"
  {
                    yyVal = new BlockNode(((Node)yyVals[0+yyTop]).getLine()).add(((Node)yyVals[0+yyTop]));
                }
  break;
case 603:
					// line 2618 "RubyParser.y"
  {
                    yyVal = support.appendToBlock(((ListNode)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 604:
					// line 2622 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 605:
					// line 2625 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 606:
					// line 2630 "RubyParser.y"
  {
                    if (!support.is_local_id(((ByteList)yyVals[0+yyTop]))) {
                        support.yyerror("rest argument must be local variable");
                    }
                    
                    yyVal = new RestArgNode(support.arg_var(support.shadowing_lvar(((ByteList)yyVals[0+yyTop]))));
                }
  break;
case 607:
					// line 2637 "RubyParser.y"
  {
  /* FIXME: bytelist_love: somewhat silly to remake the empty bytelist over and over but this type should change (using null vs "" is a strange distinction).*/
  yyVal = new UnnamedRestArgNode(lexer.getRubySourceline(), support.symbolID(CommonByteLists.EMPTY), support.getCurrentScope().addVariable("*"));
                }
  break;
case 608:
					// line 2643 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 609:
					// line 2646 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 610:
					// line 2651 "RubyParser.y"
  {
                    if (!support.is_local_id(((ByteList)yyVals[0+yyTop]))) {
                        support.yyerror("block argument must be local variable");
                    }
                    
                    yyVal = new BlockArgNode(support.arg_var(support.shadowing_lvar(((ByteList)yyVals[0+yyTop]))));
                }
  break;
case 611:
					// line 2659 "RubyParser.y"
  {
                    yyVal = ((BlockArgNode)yyVals[0+yyTop]);
                }
  break;
case 612:
					// line 2662 "RubyParser.y"
  {
                    yyVal = null;
                }
  break;
case 613:
					// line 2666 "RubyParser.y"
  {
                    value_expr(lexer, ((Node)yyVals[0+yyTop]));
                    yyVal = ((Node)yyVals[0+yyTop]);
                }
  break;
case 614:
					// line 2670 "RubyParser.y"
  {
                    lexer.setState(EXPR_BEG);
                }
  break;
case 615:
					// line 2672 "RubyParser.y"
  {
                    if (((Node)yyVals[-1+yyTop]) == null) {
                        support.yyerror("can't define single method for ().");
                    } else if (((Node)yyVals[-1+yyTop]) instanceof ILiteralNode) {
                        support.yyerror("can't define single method for literals.");
                    }
                    value_expr(lexer, ((Node)yyVals[-1+yyTop]));
                    yyVal = ((Node)yyVals[-1+yyTop]);
                }
  break;
case 616:
					// line 2683 "RubyParser.y"
  {
                    yyVal = new HashNode(lexer.getRubySourceline());
                }
  break;
case 617:
					// line 2686 "RubyParser.y"
  {
                    yyVal = support.remove_duplicate_keys(((HashNode)yyVals[-1+yyTop]));
                }
  break;
case 618:
					// line 2691 "RubyParser.y"
  {
                    yyVal = new HashNode(lexer.getRubySourceline(), ((KeyValuePair)yyVals[0+yyTop]));
                }
  break;
case 619:
					// line 2694 "RubyParser.y"
  {
                    yyVal = ((HashNode)yyVals[-2+yyTop]).add(((KeyValuePair)yyVals[0+yyTop]));
                }
  break;
case 620:
					// line 2699 "RubyParser.y"
  {
                    yyVal = support.createKeyValue(((Node)yyVals[-2+yyTop]), ((Node)yyVals[0+yyTop]));
                }
  break;
case 621:
					// line 2702 "RubyParser.y"
  {
                    Node label = support.asSymbol(support.getPosition(((Node)yyVals[0+yyTop])), ((ByteList)yyVals[-1+yyTop]));
                    yyVal = support.createKeyValue(label, ((Node)yyVals[0+yyTop]));
                }
  break;
case 622:
					// line 2706 "RubyParser.y"
  {
                    if (((Node)yyVals[-2+yyTop]) instanceof StrNode) {
                        DStrNode dnode = new DStrNode(support.getPosition(((Node)yyVals[-2+yyTop])), lexer.getEncoding());
                        dnode.add(((Node)yyVals[-2+yyTop]));
                        yyVal = support.createKeyValue(new DSymbolNode(support.getPosition(((Node)yyVals[-2+yyTop])), dnode), ((Node)yyVals[0+yyTop]));
                    } else if (((Node)yyVals[-2+yyTop]) instanceof DStrNode) {
                        yyVal = support.createKeyValue(new DSymbolNode(support.getPosition(((Node)yyVals[-2+yyTop])), ((DStrNode)yyVals[-2+yyTop])), ((Node)yyVals[0+yyTop]));
                    } else {
                        support.compile_error("Uknown type for assoc in strings: " + ((Node)yyVals[-2+yyTop]));
                    }

                }
  break;
case 623:
					// line 2718 "RubyParser.y"
  {
                    yyVal = support.createKeyValue(null, ((Node)yyVals[0+yyTop]));
                }
  break;
case 624:
					// line 2722 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 625:
					// line 2725 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 626:
					// line 2728 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 627:
					// line 2731 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 628:
					// line 2734 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 629:
					// line 2737 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 630:
					// line 2740 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 631:
					// line 2744 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 632:
					// line 2747 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 633:
					// line 2750 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 634:
					// line 2754 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 635:
					// line 2757 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 636:
					// line 2761 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 637:
					// line 2764 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 639:
					// line 2769 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 644:
					// line 2775 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 645:
					// line 2778 "RubyParser.y"
  {
                    yyVal = ((ByteList)yyVals[0+yyTop]);
                }
  break;
case 653:
					// line 2789 "RubyParser.y"
  {
                      yyVal = null;
                }
  break;
case 654:
					// line 2793 "RubyParser.y"
  {  
                  yyVal = null;
                }
  break;
					// line 10690 "-"
// ACTIONS_END
//        }
        yyTop -= yyLen[yyN];
        yyState = yyStates[yyTop];
        int yyM = yyLhs[yyN];
        if (yyState == 0 && yyM == 0) {
          if (yydebug != null) yydebug.shift(0, yyFinal);
          yyState = yyFinal;
          if (yyToken < 0) {
            yyToken = yyLex.nextToken();
//            yyToken = yyLex.advance() ? yyLex.token() : 0;
            if (yydebug != null)
               yydebug.lex(yyState, yyToken,yyName(yyToken), yyLex.value());
          }
          if (yyToken == 0) {
            if (yydebug != null) yydebug.accept(yyVal);
            return yyVal;
          }
          continue yyLoop;
        }
        if ((yyN = yyGindex[yyM]) != 0 && (yyN += yyState) >= 0
            && yyN < yyTable.length && yyCheck[yyN] == yyState)
          yyState = yyTable[yyN];
        else
          yyState = yyDgoto[yyM];
        if (yydebug != null) yydebug.shift(yyStates[yyTop], yyState);
        continue yyLoop;
      }
    }
  }

// ACTION_BODIES
					// line 2798 "RubyParser.y"

    /** The parse method use an lexer stream and parse it to an AST node 
     * structure
     */
    public RubyParserResult parse(ParserConfiguration configuration) throws IOException {
        support.reset();
        support.setConfiguration(configuration);
        support.setResult(new RubyParserResult());
        
        yyparse(lexer, configuration.isDebug() ? new YYDebug() : null);
        
        return support.getResult();
    }
}
					// line 10738 "-"
